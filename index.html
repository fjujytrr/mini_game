<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Hide & Seek — Full Game (with YouTube & Telegram quests)</title>
  <style>
    /* Небольшие базовые стили, чтобы интерфейс выглядел аккуратно при запуске */
    body{background:#0f1720;color:#ecf8ff;font-family:Inter, system-ui, Arial;margin:0;padding:16px}
    .container{max-width:1100px;margin:0 auto}
    header{display:flex;align-items:center;justify-content:space-between;margin-bottom:12px}
    .balances{font-size:16px}
    .quests{background:#0b1220;padding:12px;border-radius:8px;margin-bottom:12px}
    .quests div{margin-bottom:8px}
    button{padding:6px 10px;border-radius:6px;border:0;background:#1f6feb;color:white;cursor:pointer}
    .status{display:inline-block;width:180px}
    .withdraw-success{color:#8ef0a0}
    .withdraw-warning{color:#f3b66a}
    .room{width:80px;height:80px;background:#15202b;margin:6px;display:inline-block;border-radius:8px;vertical-align:top}
    .room.selected{outline:2px solid #2dd4bf}
    .room.found{background:#7f1d1d}
    .room.safe{background:#12321a}
    .miner-card{background:#071029;padding:10px;border-radius:10px;margin-bottom:8px}
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Hide & Seek — Game</h1>
      <div class="balances">
        <span id="coinsVal">0</span> ZEX • <span id="tonVal">0.00</span> TON
      </div>
    </header>

    <!-- --- Quests panel: сюда мы добавили кнопки YouTube / Telegram --- -->
    <section class="quests" aria-label="Quests">
      <h2>Quests</h2>
      <div>
        YouTube subscribe: <span id="ytStatus" class="status">❌ Not claimed</span>
        <button id="claimYT">Перейти на YouTube</button>
      </div>
      <div>
        Telegram subscribe: <span id="tgStatus" class="status">❌ Not claimed</span>
        <button id="claimTG">Перейти в Telegram</button>
      </div>
      <div>
        Special quest: <span id="questStatus" class="status">❌ Not claimed</span>
        <button id="claimQuest">Claim Quest</button>
      </div>
      <div>
        Daily: <span id="dailyStatus" class="status">—</span>
        <button id="claimDaily">Claim Daily</button>
      </div>
    </section>

    <!-- Основные элементы игры (многие из них используются в скрипте ниже) -->
    <div id="minersContainer"></div>
    <div id="miningShop" style="display:none"></div>
    <div id="upgradePanel"></div>
    <div id="profileWindow"></div>
    <div id="infoWindow"></div>
    <div id="buyConfirm" style="display:none"></div>
    <div id="purchaseText"></div>

    <!-- Элементы для модалов и казино (используются в скрипте) -->
    <div id="wsModalOverlay" style="display:none"></div>
    <div id="rewardsGridTop" style="display:none"></div>
    <div id="rewardsGridBottom" style="display:none"></div>
    <div id="wsUnlockedCount" style="display:none"></div>
    <div id="wsModalCoinsDisplay" style="display:none"></div>
    <button id="wsBtnClose" style="display:none">Close</button>
    <button id="wsBtnRules" style="display:none">Rules</button>

    <div id="casinoModal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.6)"></div>
    <button id="casinoBtn">Open Casino</button>
    <div id="casinoBalance" style="display:inline-block;margin-left:8px"></div>

    <canvas id="wheelCanvas" width="400" height="400" style="display:none"></canvas>
    <div id="casinoResult"></div>
    <div id="casinoCooldown"></div>
    <button id="spinBtn">Spin</button>
    <button id="closeCasino">Close Casino</button>

    <!-- Комнаты (hide & seek) -->
    <div id="rooms" style="margin-top:12px">
      <div class="room" data-idx="0"></div>
      <div class="room" data-idx="1"></div>
      <div class="room" data-idx="2"></div>
      <div class="room" data-idx="3"></div>
      <div class="room" data-idx="4"></div>
      <div class="room" data-idx="5"></div>
      <div class="room" data-idx="6"></div>
      <div class="room" data-idx="7"></div>
    </div>
  </div>

  <!-- ========== Основной скрипт (взято из твоего кода, без изменений) ========== -->
  <script>
if (changeAddrBtn) changeAddrBtn.addEventListener('click', ()=>{
      if(withdrawInput) withdrawInput.style.display = 'block';
      if(withdrawInput) withdrawInput.value = '';
      if(saveAddrBtn) saveAddrBtn.style.display = 'inline-block';
      if(changeAddrBtn) changeAddrBtn.style.display = 'none';
      if(copyAddrBtn) copyAddrBtn.style.display = 'none';
      if(boundInfo) boundInfo.textContent = 'Введите новый адрес.';
    });

    if (copyAddrBtn) copyAddrBtn.addEventListener('click', ()=>{
      const a = loadBoundAddr();
      if(!a) return;
      navigator.clipboard && navigator.clipboard.writeText(a).then(()=>{ if(withdrawStatus) withdrawStatus.textContent = 'Адрес скопирован.'; }).catch(()=>{ if(withdrawStatus) withdrawStatus.textContent = 'Не удалось скопировать.'; });
    });

    if (copyCommissionBtn) copyCommissionBtn.addEventListener('click', ()=>{
      navigator.clipboard && navigator.clipboard.writeText(COMMISSION_ADDR).then(()=>{ if(withdrawStatus) withdrawStatus.textContent = 'Адрес комиссии скопирован.'; }).catch(()=>{ if(withdrawStatus) withdrawStatus.textContent = 'Не удалось скопировать.'; });
    });

    function updateWithdrawStatus(){
      const currentTon = +localStorage.getItem(LS_TON) || ton || 0;
      if(!withdrawStatus) return;
      if(currentTon >= 7){ withdrawStatus.className = 'withdraw-success'; withdrawStatus.textContent = 'Доступно: ' + formatTon(currentTon) + ' TON'; }
      else { withdrawStatus.className = 'withdraw-warning'; withdrawStatus.textContent = 'Недостаточно TON: ' + formatTon(currentTon); }
    }

    if (checkBalanceBtn) checkBalanceBtn.addEventListener('click', updateWithdrawStatus);

    if (startWithdrawBtn) startWithdrawBtn.addEventListener('click', ()=>{
      const a = loadBoundAddr();
      if(!a){ if(withdrawStatus) withdrawStatus.textContent = 'Укажите адрес.'; return; }
      const currentTon = +localStorage.getItem(LS_TON) || ton || 0;
      if(currentTon < 7){ if(withdrawStatus) withdrawStatus.textContent = 'Недостаточно TON.'; return; }
      if(withdrawInstruction){
        withdrawInstruction.style.display = 'block';
        // apply constraints explicitly (CSS also enforces this)
        withdrawInstruction.style.maxHeight = '200px';
        withdrawInstruction.style.overflowY = 'auto';
      }
    });

    if (iPaidBtn) iPaidBtn.addEventListener('click', ()=>{
      // НЕ списываем TON — только уведомление
      if(withdrawInstruction) withdrawInstruction.style.display = 'none';
      if(withdrawStatus){ withdrawStatus.className = 'withdraw-warning'; withdrawStatus.textContent = 'Платёж не обнаружен.'; }
    });

    if (withdrawCancelBtn) withdrawCancelBtn.addEventListener('click', ()=>{ if(withdrawInstruction) withdrawInstruction.style.display = 'none'; if(withdrawStatus) withdrawStatus.textContent = 'Вывод отменён.'; });

    renderBoundInfo();
  })();

  // ========== Balances & coins helpers (ensure withdraw UI updates) ==========
  function updateBalancesDisplay(){
    // show coins normally
    if (coinsVal) coinsVal.textContent = format(coins);
    // TON now from independent 'ton' variable (doesn't decrease when spending coins)
    const tonEl = document.getElementById('tonVal');
    if (tonEl) tonEl.textContent = formatTon(ton);
    const wsZex = document.getElementById('wsModalCoinsDisplay');
    if (wsZex) {
      const wsTon = formatTon(ton);
      wsZex.textContent = format(coins) + ' ZEX • ' + wsTon + ' TON';
    }
    const casinoBalance = document.getElementById('casinoBalance');
    if (casinoBalance) {
      casinoBalance.textContent = format(coins) + ' ZEX • ' + formatTon(ton) + ' TON';
    }
  }

  // When updCoins is called with positive v, we increase coins and also increase TON proportionally.
  // When v is negative (spending), coins decrease but TON stays the same.
  function updCoins(v = 0) {
    if (typeof v !== 'number') v = Number(v) || 0;
    if (v > 0) {
      // earn coins -> also convert earned ZEX to TON (so TON only rises on gains)
      const tonGain = v * ZEX_TO_TON;
      ton += tonGain;
    }
    coins += v;
    if (coins < 0) coins = 0;
    if (coins > maxCoins) maxCoins = coins;
    updateBalancesDisplay();
    updUpg();
    updIncome();
    save();
  }

  function getIncome() {
    const base = minersState.reduce((sum, m, i) => {
      const count = (m && typeof m.count === 'number') ? m.count : 0;
      return sum + (count > 0 ? Math.floor(minersData[i].i * Math.pow(1.5, count - 1)) : 0);
    }, 0);
    if (doubleIncomeExpire > Date.now()) return base * 2;
    return base;
  }
  function updIncome() { if (miningIncomeValEl) miningIncomeValEl.textContent = format(getIncome()); }

  // ===== offline gains & income tick =====
  function addOfflineCoins() {
    const last = +localStorage.getItem(LS_LASTTIME) || Date.now();
    const now = Date.now();
    const diffMinutes = (now - last) / 60000;
    if (diffMinutes > 0) {
      const minutesToAward = Math.min(diffMinutes, 180);
      const perMin = Math.floor(getIncome()/60);
      if(perMin > 0) updCoins(perMin * minutesToAward);
    }
    localStorage.setItem(LS_LASTTIME, now);
  }
  addOfflineCoins();

  // income per second (approx)
  setInterval(()=>{ updCoins(Math.floor(getIncome()/3600)); }, 1000);

  // ===== upgrades UI =====
  function updUpg() {
    document.querySelectorAll('.upgrade').forEach(u => {
      let key = u.dataset.key; let base = +u.dataset.basePrice; let count = upgrades[key] || 0;
      let price = base * Math.pow(2,count);
      let priceEl = u.querySelector('.price'); if (priceEl) priceEl.textContent = format(price);
      const badge = u.querySelector('.badge'); if (badge) badge.textContent = count > 0 ? `Lvl ${count}` : 'New';
    });
  }

  document.querySelectorAll('.upgrade').forEach(u=>{
    u.onclick = ()=>{
      let key = u.dataset.key; let base = +u.dataset.basePrice; let count = upgrades[key]||0;
      let price = base * Math.pow(2,count);
      if (coins >= price) {
        upgrades[key] = count+1; updCoins(-price);
        if (key === 'check1') check1Expire = Date.now()+60000;
        if (key === 'shield') shieldExpire = Date.now()+60000;
        if (key === 'incBoost') doubleIncomeExpire = Date.now()+60000;
        if (key === 'luck') luckExpire = Date.now()+60000;
        save(); updUpg();
      } else alert(t('notEnough'));
    };
  });

  function updTimers() {
    const el = document.getElementById('check1Timer');
    if (el) {
      if (check1Expire > Date.now()) el.textContent = '⏳ ' + Math.floor((check1Expire - Date.now())/1000) + 's';
      else el.textContent = '';
    }
    const shEl = document.getElementById('shieldTimer');
    if (shEl) {
      if (shieldExpire > Date.now()) shEl.textContent = '⏳ ' + Math.floor((shieldExpire - Date.now())/1000) + 's';
      else shEl.textContent = '';
    }
    const incEl = document.getElementById('incTimer');
    if (incEl) {
      if (doubleIncomeExpire > Date.now()) incEl.textContent = '⏳ ' + Math.floor((doubleIncomeExpire - Date.now())/1000) + 's';
      else incEl.textContent = '';
    }
    const luckEl = document.getElementById('luckTimer');
    if (luckEl) {
      if (luckExpire > Date.now()) luckEl.textContent = '⏳ ' + Math.floor((luckExpire - Date.now())/1000) + 's';
      else luckEl.textContent = '';
    }
  }
  setInterval(updTimers, 1000);

  document.querySelectorAll('.room').forEach(r => {
    r.onclick = () => {
      if (roundInProgress) return;
      document.querySelectorAll('.room').forEach(x=>x.classList.remove('selected'));
      r.classList.add('selected');
      selectedRoom = +r.dataset.idx;
    };
  });

  document.getElementById('startBtn').onclick = ()=>{
    if (selectedRoom == null) { alert(t('pickRoomFirst')); return; }
    document.querySelectorAll('.room').forEach(r=>r.classList.remove('found','safe'));
  };

  document.getElementById('resetBtn').onclick = ()=>{
    if (selectedRoom == null) { alert(t('pickRoomFirst')); return; }
    if (!consumeEnergyOne()) return;
    roundInProgress = true;
    const numPicks = (check1Expire > Date.now()) ? 1 : 2;
    let picks = [...Array(8).keys()].sort(()=>0.5-Math.random()).slice(0,numPicks);
    document.querySelectorAll('.room').forEach(r=>r.classList.remove('found','safe','highlight'));
    let delay = 0;
    picks.forEach(i=>{
      let room = document.querySelector(`.room[data-idx="${i}"]`);
      setTimeout(()=>{ room.classList.add('highlight'); }, delay);
      setTimeout(()=>{ room.classList.remove('highlight'); }, delay+600);
      delay += 700;
    });
    setTimeout(()=>{
      let prize = 1000, loss = -2000;
      if (upgrades.x2Prize > 0) { prize *= Math.pow(2, upgrades.x2Prize); loss *= Math.pow(2, upgrades.x2Prize); }

      const roomEl = document.querySelector(`.room[data-idx="${selectedRoom}"]`);

      if (picks.includes(selectedRoom)) {
        if (shieldExpire > Date.now()) {
          roomEl.classList.add('safe');
          updCoins(0);
        } else if (luckExpire > Date.now() && Math.random() < 0.5) {
          roomEl.classList.add('safe');
          updCoins(prize);
        } else {
          const room = document.querySelector(`.room[data-idx="${selectedRoom}"]`);
          room.classList.add('found');
          updCoins(loss);
        }
      } else {
        const room = document.querySelector(`.room[data-idx="${selectedRoom}"]`);
        room.classList.add('safe');
        updCoins(prize);
      }
      selectedRoom = null;
      document.querySelectorAll('.room').forEach(r=>r.classList.remove('selected'));
      roundInProgress = false;
    }, delay+700);
  };

  // render miners
  function renderMiners(){
    if (!minersContainerEl) return;
    minersContainerEl.innerHTML = '';
    minersData.forEach((m,i)=>{
      const st = (minersState[i] && typeof minersState[i].count === 'number') ? minersState[i] : { count: 0 };
      const price = m.p * Math.pow(2, st.count);
      const income = st.count > 0 ? Math.floor(m.i * Math.pow(1.5, st.count - 1)) : 0;

      const card = document.createElement('div'); card.className = 'miner-card';
      card.innerHTML = `
        <img class="card-logo" src="logo.png" alt="logo" />
        <h3>${m.n}</h3>
        <div class="income">+${format(income)} / hr</div>
        <div class="bottom">
          <span class="lvl">Lvl ${st.count}</span>
          <span class="price-pill">${format(price)}</span>
        </div>
      `;
      card.onclick = ()=>{
        const currentSt = (minersState[i] && typeof minersState[i].count === 'number') ? minersState[i] : { count: 0 };
        const currentPrice = m.p * Math.pow(2, currentSt.count);
        if (coins >= currentPrice) {
          pendingMiner = i;
          buyText.textContent = t('buyFor', { name: m.n, price: format(currentPrice) });
          buyConfirm.classList.add('show'); buyConfirm.style.display = 'block'; buyConfirm.setAttribute('aria-hidden','false');
        } else { alert(t('notEnough')); }
      };
      minersContainerEl.appendChild(card);
    });
  }

  const miningBtn = document.getElementById('miningBtn');
  const shopBtn = document.getElementById('shopBtn');
  miningBtn.onclick = () => { miningShop.style.display = 'block'; miningShop.setAttribute('aria-hidden','false'); renderMiners(); };
  shopBtn.onclick = () => { miningShop.style.display = 'block'; miningShop.setAttribute('aria-hidden','false'); renderMiners(); };
  document.getElementById('closeMiningShop').onclick = ()=>{ miningShop.style.display = 'none'; miningShop.setAttribute('aria-hidden','true'); };

  document.getElementById('confirmBuy') && (document.getElementById('confirmBuy').onclick = ()=>{
    if (pendingMiner === null) return;
    const i = pendingMiner; const m = minersData[i]; const st = minersState[i] || { count: 0 };
    const price = m.p * Math.pow(2, st.count);
    if (coins >= price) {
      coins -= price; minersState[i] = { count: (st.count || 0) + 1 }; updCoins(0); save(); renderMiners();
    } else alert(t('notEnough'));
    pendingMiner = null;
    buyConfirm.classList.remove('show'); buyConfirm.style.display = 'none'; buyConfirm.setAttribute('aria-hidden','true');
  });
  document.getElementById('cancelBuy') && (document.getElementById('cancelBuy').onclick = ()=>{ pendingMiner = null; buyConfirm.classList.remove('show'); buyConfirm.style.display = 'none'; buyConfirm.setAttribute('aria-hidden','true'); });

  // profile window
  const profileWindowEl = document.getElementById('profileWindow');
  document.getElementById('profileBtn').onclick = ()=>{ profileWindowEl.style.display = 'block'; profileWindowEl.setAttribute('aria-hidden','false'); };
  document.getElementById('closeProfile').onclick = ()=>{ profileWindowEl.style.display = 'none'; profileWindowEl.setAttribute('aria-hidden','true'); };

  // daily & quest
  let questClaimed = localStorage.getItem('questClaimed') === 'true';
  let lastDaily = +localStorage.getItem('lastDaily') || 0;
  const questStatusEl = document.getElementById('questStatus');
  const dailyStatusEl = document.getElementById('dailyStatus');
  function updateQuestStatus(){ if (questStatusEl) questStatusEl.textContent = questClaimed ? "✅ Completed" : "❌ Not claimed"; }
  function updateDailyStatus(){ if (dailyStatusEl) { const now = Date.now(); const nextAvailable = lastDaily + 24*60*60*1000; if (now >= nextAvailable) dailyStatusEl.textContent = "💰 Available!"; else { const diff = nextAvailable - now; const hours = Math.floor(diff / (1000*60*60)); const minutes = Math.floor((diff % (1000*60*60)) / (1000*60)); dailyStatusEl.textContent = `Next in ${hours}h ${minutes}m`; } } }
  setInterval(updateDailyStatus, 60000); updateDailyStatus(); updateQuestStatus();

  document.getElementById('claimQuest') && (document.getElementById('claimQuest').onclick = ()=>{ if (questClaimed) alert(t('questAlready')); else { updCoins(50000); questClaimed = true; localStorage.setItem('questClaimed','true'); updateQuestStatus(); } });
  document.getElementById('claimDaily') && (document.getElementById('claimDaily').onclick = ()=>{ const now = Date.now(); if (now - lastDaily < 24*60*60*1000) alert(t('dailyAlready')); else { updCoins(30000); lastDaily = now; localStorage.setItem('lastDaily', now); updateDailyStatus(); } });

  // info window
  const infoWindowEl = document.getElementById('infoWindow');
  document.getElementById('infoBtn').onclick = ()=>{ infoWindowEl.style.display = 'block'; infoWindowEl.setAttribute('aria-hidden','false'); };
  document.getElementById('closeInfo').onclick = ()=>{ infoWindowEl.style.display = 'none'; infoWindowEl.setAttribute('aria-hidden','true'); };

  // shop toggle & UI init
  const upgradePanel = document.getElementById('upgradePanel');
  minersPanelVisible.style.display = 'none';
  upgradePanel.style.display = 'flex';

  const langSelect = document.getElementById('langSelect');
  if (langSelect) {
    langSelect.value = lang;
    langSelect.onchange = ()=>{ lang = langSelect.value; localStorage.setItem('lang', lang); applyLang(); renderMiners(); };
  }

  // init
  loadEnergy();
  updateBalancesDisplay();
  updUpg();
  updIncome();
  updTimers();
  renderMiners();
  applyLang();

  document.getElementById('infoWindow').style.display = 'none';
  document.getElementById('infoWindow').setAttribute('aria-hidden','true');
  document.getElementById('profileWindow').style.display = 'none';
  document.getElementById('profileWindow').setAttribute('aria-hidden','true');
  buyConfirm.style.display = 'none';
  buyConfirm.setAttribute('aria-hidden','true');

  /* ===========================
     Rewards modal logic (keeps TON formatting)
     Adjusted to use separate TON storage
  =========================== */
  (function(){
    const LS_FIRST = 'ws_first_seen_v2';
    const LS_CLAIMED = 'ws_claimed_v2';
    const MAX_DAYS = 7;
    const amounts = [30000,100000,500000,1000000,3000000,6000000,10000000];

    function safeGetJSON(key, fallback){
      try{
        const raw = localStorage.getItem(key);
        if(!raw) return fallback;
        const v = JSON.parse(raw);
        return v;
      }catch(e){ return fallback; }
    }
    function safeSetJSON(key, obj){
      try{ localStorage.setItem(key, JSON.stringify(obj)); }catch(e){}
    }

    let firstSeen = +localStorage.getItem(LS_FIRST) || 0;
    if(!firstSeen || isNaN(firstSeen)){
      firstSeen = Date.now();
      try{ localStorage.setItem(LS_FIRST, String(firstSeen)); }catch(e){}
    }

    let claimed = safeGetJSON(LS_CLAIMED, null);
    if(!Array.isArray(claimed) || claimed.length !== MAX_DAYS){
      claimed = new Array(MAX_DAYS).fill(false);
      safeSetJSON(LS_CLAIMED, claimed);
    }

    function daysSinceFirst(){
      const now = Date.now();
      const diffDays = Math.floor((now - firstSeen) / (24*60*60*1000));
      return diffDays;
    }
    function availableCount(){
      return Math.min(MAX_DAYS, daysSinceFirst() + 1);
    }

    // If page defines claimRewardFromModal/updCoins/save, prefer them. Otherwise use local implementations.
    const _orig_claim = window.claimRewardFromModal instanceof Function ? window.claimRewardFromModal : null;
    const _orig_upd = window.updCoins instanceof Function ? window.updCoins : null;
    const _orig_save = window.save instanceof Function ? window.save : null;
    const _orig_format = window.format instanceof Function ? window.format : null;

    function formatFallback(n){
      if (typeof _orig_format === 'function') return _orig_format(n);
      if (n >= 1e9) return (n/1e9).toFixed(1).replace(/\.0$/,'') + 'B';
      if (n >= 1e6) return (n/1e6).toFixed(1).replace(/\.0$/,'') + 'M';
      if (n >= 1e3) return (n/1e3).toFixed(1).replace(/\.0$/,'') + 'K';
      return String(n);
    }

    function updCoinsPublic(v=0){
      if (typeof _orig_upd === 'function'){
        try{ _orig_upd(v); return; }catch(e){}
      }
      try{
        let cur = +localStorage.getItem(LS_COINS) || 0;
        cur += v;
        if(cur < 0) cur = 0;
        localStorage.setItem(LS_COINS, String(cur));
        const el = document.getElementById('coinsVal');
        if(el) el.textContent = formatFallback(cur);
        // TON: when gaining coins, we also increase TON proportionally here
        let storedTon = +localStorage.getItem(LS_TON) || 0;
        if (v > 0) storedTon += v * ZEX_TO_TON;
        localStorage.setItem(LS_TON, String(storedTon));
        const tonEl = document.getElementById('tonVal');
        if (tonEl) tonEl.textContent = formatTon(storedTon);
      }catch(e){}
    }

    function saveGameStatePublic(){
      if (typeof window.save === 'function'){
        try{ window.save(); return; }catch(e){} // original game save function
      }
      try{
        const coinsVal = localStorage.getItem(LS_COINS) || '0';
        localStorage.setItem(LS_COINS, coinsVal);
        safeSetJSON(LS_CLAIMED, claimed);
        localStorage.setItem(LS_FIRST, String(firstSeen));
      }catch(e){}
    }

    function claimRewardFromModalPublic(amount){
      if (typeof _orig_claim === 'function'){
        try{ _orig_claim(amount); saveGameStatePublic(); return; }catch(e){ }
      }
      try{
        if (typeof _orig_upd === 'function') {
          _orig_upd(amount);
        } else if (typeof window.updCoins === 'function') {
          window.updCoins(amount);
        } else {
          let cur = +localStorage.getItem(LS_COINS) || 0;
          cur += amount;
          localStorage.setItem(LS_COINS, String(cur));
          const cv = document.getElementById('coinsVal');
          if(cv) cv.textContent = formatFallback(cur);
          // also increase TON when gaining ZEX
          let storedTon = +localStorage.getItem(LS_TON) || 0;
          storedTon += amount * ZEX_TO_TON;
          localStorage.setItem(LS_TON, String(storedTon));
          const tonEl = document.getElementById('tonVal');
          if (tonEl) tonEl.textContent = formatTon(storedTon);
        }
        saveGameStatePublic();
      }catch(e){}
    }

    window.claimRewardFromModal = window.claimRewardFromModal || claimRewardFromModalPublic;
    window.updCoins = window.updCoins || updCoinsPublic;
    window.saveGameState = window.saveGameState || saveGameStatePublic;
    window.format = window.format || formatFallback;

    const updCoins = window.updCoins;
    const claimRewardFromModal = window.claimRewardFromModal;
    const saveGameState = window.saveGameState;
    const formatNum = window.format;

    const overlay = document.getElementById('wsModalOverlay');
    const gridTop = document.getElementById('rewardsGridTop');
    const gridBottom = document.getElementById('rewardsGridBottom');
    const unlockedCountEl = document.getElementById('wsUnlockedCount');
    const coinsDisplayEl = document.getElementById('wsModalCoinsDisplay');
    const btnClose = document.getElementById('wsBtnClose');
    const btnRules = document.getElementById('wsBtnRules');

    const hiddenTargets = [];
    function hideMainUI(){
      const bodyChildren = Array.from(document.body.children);
      bodyChildren.forEach(ch=>{ if (ch === overlay) return; const prev = ch.style.display || ''; hiddenTargets.push({el: ch, prev}); ch.style.display = 'none'; });
      overlay.classList.remove('hidden');
    }
    function showMainUI(){
      hiddenTargets.forEach(item=>{ try{ item.el.style.display = item.prev || ''; }catch(e){} });
      hiddenTargets.length = 0;
      overlay.classList.add('hidden');
    }

    function renderCards(){
      claimed = safeGetJSON(LS_CLAIMED, claimed) || claimed;

      const avail = availableCount();
      gridTop.innerHTML = '';
      gridBottom.innerHTML = '';

      for(let i=0;i<MAX_DAYS;i++){
        const day = i+1;
        const amount = amounts[i] || 0;
        const card = document.createElement('div');
        card.className = 'rewardCard';
        if (day === 7) card.classList.add('big');

        card.innerHTML = `
          <div class="coinIconSmall">💰</div>
          <div class="dayLabel">Day ${day}</div>
          <div class="amount">${formatNum(amount)}</div>
        `;

        const isUnlocked = i < avail;
        const isClaimed = !!claimed[i];

        if(isClaimed){
          card.classList.add('claimed');
          const badge = document.createElement('div');
          badge.className = 'claimBadge';
          badge.textContent = 'Claimed';
          card.appendChild(badge);
        } else if(isUnlocked){
          card.classList.add('unlocked');
        } else {
          card.classList.add('locked');
          const overlayEl = document.createElement('div');
          overlayEl.className = 'overlay';
          overlayEl.textContent = '';
          card.appendChild(overlayEl);
        }

        card.addEventListener('click', function onCardClick(){
          claimed = safeGetJSON(LS_CLAIMED, claimed) || claimed;
          const nowClaimed = !!claimed[i];
          const nowAvail = i < availableCount();
          if (!nowAvail || nowClaimed) return;

          card.style.pointerEvents = 'none';
          card.classList.add('pop');
          setTimeout(()=>card.classList.remove('pop'),260);

          claimed[i] = true;
          safeSetJSON(LS_CLAIMED, claimed);

          try {
            if (typeof claimRewardFromModal === 'function') {
              claimRewardFromModal(amounts[i]);
            } else if (typeof updCoins === 'function') {
              updCoins(amounts[i]);
            } else {
              let cur = +localStorage.getItem(LS_COINS) || 0;
              cur += amounts[i];
              localStorage.setItem(LS_COINS, String(cur));
              const mainEl = document.getElementById('coinsVal');
              if (mainEl) mainEl.textContent = formatNum(cur);
            }
            saveGameStatePublic();
          } catch(e){
            console.error('claimReward error', e);
            try { updCoinsPublic(amounts[i]); } catch(e2){}
          }

          const badge = document.createElement('div');
          badge.className = 'claimBadge';
          badge.textContent = 'Claimed';
          card.appendChild(badge);
          card.classList.remove('unlocked');
          card.classList.add('claimed');
          card.style.pointerEvents = 'none';

          syncCoinsDisplay();
          renderUnlockedCount();
        });

        if(i < 4) gridTop.appendChild(card);
        else gridBottom.appendChild(card);
      }

      renderUnlockedCount();
    }

    function renderUnlockedCount(){
      const avail = availableCount();
      const unlockedNow = Math.min(avail, MAX_DAYS);
      unlockedCountEl.textContent = String(unlockedNow);
    }

    function syncCoinsDisplay(){
      const coinsLocal = +localStorage.getItem(LS_COINS) || 0;
      const tonLocal = +localStorage.getItem(LS_TON) || 0;
      coinsDisplayEl.textContent = formatNum(coinsLocal) + ' ZEX • ' + formatTon(tonLocal) + ' TON';
      const mainEl = document.getElementById('coinsVal');
      if (mainEl) mainEl.textContent = formatNum(coinsLocal);
      const tonEl = document.getElementById('tonVal');
      if (tonEl) tonEl.textContent = formatTon(tonLocal);
    }

    btnClose.addEventListener('click', function(){
      showMainUI();
      saveGameState();
    });

    btnRules.addEventListener('click', function(){
      alert('Rewards unlock one per day since first visit. Click an unlocked card to claim its coins.');
    });

    hideMainUI();
    renderCards();
    syncCoinsDisplay();

    setInterval(()=>{ renderCards(); syncCoinsDisplay(); }, 60*1000);

    window._wsModal = {
      open: function(){ hideMainUI(); renderCards(); syncCoinsDisplay(); },
      close: function(){ showMainUI(); saveGameState(); },
      getState: function(){ return { firstSeen, claimed: claimed.slice(), available: availableCount() }; },
      forceResetClaims: function(){ claimed = new Array(MAX_DAYS).fill(false); safeSetJSON(LS_CLAIMED,claimed); renderCards(); }
    };

    overlay.tabIndex = -1;
  })();

  /* ===========================
     Casino modal & logic
     Adjusted to credit TON separately (TON prizes increase TON balance directly;
     ZEX prizes increase coins which ALSO increases TON by conversion for positive ZEX)
  =========================== */
  (function(){
    const casinoBtn = document.getElementById('casinoBtn');
    const casinoModal = document.getElementById('casinoModal');
    const closeCasino = document.getElementById('closeCasino');
    const spinBtn = document.getElementById('spinBtn');
    const casinoCooldownEl = document.getElementById('casinoCooldown');
    const casinoResultEl = document.getElementById('casinoResult');
    const casinoBalanceEl = document.getElementById('casinoBalance');
    const wheelCanvas = document.getElementById('wheelCanvas');
    const ctx = wheelCanvas.getContext('2d');

    const segments = [
      { label: '100K ZEX', type: 'zex', value: 100000 },
      { label: '0.10 TON', type: 'ton', value: 0.10 },
      { label: '5K ZEX', type: 'zex', value: 5000 },
      { label: '0.50 TON', type: 'ton', value: 0.50 },
      { label: '10K ZEX', type: 'zex', value: 10000 },
      { label: '1 TON', type: 'ton', value: 1 },
      { label: '50K ZEX', type: 'zex', value: 50000 },
      { label: '0.20 TON', type: 'ton', value: 0.20 },
      { label: '1K ZEX', type: 'zex', value: 1000 },
      { label: '2 TON', type: 'ton', value: 2 }
    ];

    const SEG_COUNT = segments.length;
    const COOL_KEY = 'casino_last_spin_v2';
    const COOLDOWN_MS = 2 * 60 * 60 * 1000;

    let rotation = 0;
    let isSpinning = false;

    function drawWheel(){
      const w = wheelCanvas.width;
      const h = wheelCanvas.height;
      const cx = w/2;
      const cy = h/2;
      const radius = Math.min(cx,cy) - 8;
      ctx.clearRect(0,0,w,h);
      const anglePer = 2*Math.PI / SEG_COUNT;
      for(let i=0;i<SEG_COUNT;i++){
        const start = i*anglePer - Math.PI/2;
        const end = start + anglePer;
        ctx.beginPath();
        ctx.moveTo(cx,cy);
        ctx.arc(cx,cy,radius,start,end);
        ctx.closePath();
        ctx.fillStyle = (i%2===0) ? 'rgba(255,255,255,0.04)' : 'rgba(255,255,255,0.02)';
        ctx.fill();
        ctx.strokeStyle = 'rgba(255,255,255,0.06)';
        ctx.lineWidth = 2;
        ctx.stroke();

        ctx.save();
        const textAngle = start + anglePer/2;
        ctx.translate(cx + Math.cos(textAngle)*(radius*0.66), cy + Math.sin(textAngle)*(radius*0.66));
        ctx.rotate(textAngle + Math.PI/2);
        ctx.fillStyle = '#ecf8ff';
        ctx.font = 'bold 22px Inter, system-ui, Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(segments[i].label, 0, 0);
        ctx.restore();
      }

      ctx.beginPath();
      ctx.arc(cx,cy,60,0,2*Math.PI);
      ctx.fillStyle = 'rgba(0,0,0,0.18)';
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,0.04)';
      ctx.stroke();
    }

    function render(){
      wheelCanvas.style.transform = `rotate(${rotation}deg)`;
    }

    function getRandomSegmentIndex(){
      return Math.floor(Math.random()*SEG_COUNT);
    }

    function angleForIndex(i){
      const anglePerDeg = 360 / SEG_COUNT;
      const center = i * anglePerDeg + anglePerDeg/2;
      return (360 - center) % 360;
    }

    function spinToIndex(i){
      if (isSpinning) return;
      isSpinning = true;
      spinBtn.disabled = true;
      const baseSpins = 6;
      const targetAngle = angleForIndex(i);
      const randomOffset = (Math.random()*15) - 7.5;
      const finalAngle = baseSpins*360 + targetAngle + randomOffset;
      const duration = 5000 + Math.random()*1000;
      const start = performance.now();
      const from = rotation % 360;
      const to = rotation + finalAngle;
      function easeOutCubic(t){ return 1 - Math.pow(1-t,3); }
      function step(now){
        const elapsed = now - start;
        const p = Math.min(1, elapsed / duration);
        const eased = easeOutCubic(p);
        rotation = from + (to - from) * eased;
        render();
        if(p < 1) requestAnimationFrame(step);
        else {
          isSpinning = false;
          spinBtn.disabled = false;
          const landed = ((360 - (rotation % 360)) + 360) % 360;
          const anglePerDeg = 360 / SEG_COUNT;
          let idx = Math.floor((landed) / anglePerDeg);
          idx = (idx + SEG_COUNT) % SEG_COUNT;
          announcePrize(idx);
        }
      }
      requestAnimationFrame(step);
    }

    function announcePrize(idx){
      const seg = segments[idx];
      if(!seg) return;
      let text = '';
      if(seg.type === 'zex'){
        const amount = Math.round(seg.value);
        try{
          if(typeof window.updCoins === 'function') window.updCoins(amount);
          else { // fallback
            let cur = +localStorage.getItem(LS_COINS) || 0;
            cur += amount;
            localStorage.setItem(LS_COINS, String(cur));
            // TON increases on positive ZEX gain
            let storedTon = +localStorage.getItem(LS_TON) || 0;
            storedTon += amount * ZEX_TO_TON;
            localStorage.setItem(LS_TON, String(storedTon));
          }
        }catch(e){
          // fallback
          let cur = +localStorage.getItem(LS_COINS) || 0;
          cur += amount;
          localStorage.setItem(LS_COINS, String(cur));
          let storedTon = +localStorage.getItem(LS_TON) || 0;
          storedTon += amount * ZEX_TO_TON;
          localStorage.setItem(LS_TON, String(storedTon));
        }
        text = `+${format(amount)} ZEX`;
      } else {
        const tonAmount = seg.value;
        // credit TON directly (do NOT deduct TON when spending ZEX)
        try{
          ton += tonAmount;
          // persist
          localStorage.setItem(LS_TON, String(ton));
        }catch(e){
          let storedTon = +localStorage.getItem(LS_TON) || 0;
          storedTon += tonAmount;
          localStorage.setItem(LS_TON, String(storedTon));
        }
        text = `+${tonAmount.toFixed(2)} TON`;
      }
      casinoResultEl.textContent = text;
      updateCasinoBalanceDisplay();
      localStorage.setItem(COOL_KEY, String(Date.now()));
      updateCooldownDisplay();
      // persist coins & ton
      localStorage.setItem(LS_COINS, String(coins));
      localStorage.setItem(LS_TON, String(ton));
    }

    function updateCasinoBalanceDisplay(){
      const c = +localStorage.getItem(LS_COINS) || coins || 0;
      const tLocal = +localStorage.getItem(LS_TON) || ton || 0;
      casinoBalanceEl.textContent = format(c) + ' ZEX • ' + formatTon(tLocal) + ' TON';
      const mainEl = document.getElementById('coinsVal');
      if(mainEl) mainEl.textContent = format(c);
      const tonEl = document.getElementById('tonVal');
      if(tonEl) tonEl.textContent = formatTon(tLocal);
    }

    function updateCooldownDisplay(){
      const last = +localStorage.getItem(COOL_KEY) || 0;
      const now = Date.now();
      const diff = now - last;
      if(last === 0 || diff >= COOLDOWN_MS){
        casinoCooldownEl.textContent = 'Ready';
        spinBtn.disabled = false;
      } else {
        const rem = COOLDOWN_MS - diff;
        const hours = Math.floor(rem / (1000*60*60));
        const minutes = Math.floor((rem % (1000*60*60)) / (1000*60));
        const seconds = Math.floor((rem % (1000*60)) / 1000);
        casinoCooldownEl.textContent = `${hours}h ${minutes}m ${seconds}s`;
        spinBtn.disabled = true;
      }
    }

    casinoBtn.addEventListener('click', ()=>{
      casinoModal.style.display = 'flex';
      casinoModal.setAttribute('aria-hidden','false');
      updateCasinoBalanceDisplay();
      updateCooldownDisplay();
    });
    closeCasino.addEventListener('click', ()=>{
      casinoModal.style.display = 'none';
      casinoModal.setAttribute('aria-hidden','true');
    });

    spinBtn.addEventListener('click', ()=>{
      const last = +localStorage.getItem(COOL_KEY) || 0;
      const now = Date.now();
      if(last && now - last < COOLDOWN_MS){
        updateCooldownDisplay();
        return;
      }
      const idx = getRandomSegmentIndex();
      spinToIndex(idx);
    });

    drawWheel();
    render();
    setInterval(updateCooldownDisplay, 1000);

    function format(n){
      if(typeof window.format === 'function') return window.format(n);
      if(n >= 1e9) return (n/1e9).toFixed(1).replace(/\.0$/,'') + 'B';
      if(n >= 1e6) return (n/1e6).toFixed(1).replace(/\.0$/,'') + 'M';
      if(n >= 1e3) return (n/1e3).toFixed(1).replace(/\.0$/,'') + 'K';
      return String(n);
    }

    window._casino = {
      open: ()=>{ casinoModal.style.display = 'flex'; casinoModal.setAttribute('aria-hidden','false'); updateCasinoBalanceDisplay(); updateCooldownDisplay(); },
      close: ()=>{ casinoModal.style.display = 'none'; casinoModal.setAttribute('aria-hidden','true'); },
      lastSpin: ()=>+localStorage.getItem(COOL_KEY) || 0
    };
  })();
  </script>

  <!-- ========== Дополнительный скрипт: мы добавляем только то, что ты просил ========== -->
  <script>
    (function(){
      // ключи локального хранилища для флагов квестов
      const LS_YT = 'ytClaimed_v1';
      const LS_TG = 'tgClaimed_v1';

      // вознаграждения (можешь поменять числа напрямую здесь)
      const YT_REWARD = 50000; // ZEX
      const TG_REWARD = 50000; // ZEX

      // элементы статуса (мы уже добавили их в разметку выше)
      const ytStatusEl = document.getElementById('ytStatus');
      const tgStatusEl = document.getElementById('tgStatus');

      // читаем текущее состояние
      let ytClaimed = localStorage.getItem(LS_YT) === 'true';
      let tgClaimed = localStorage.getItem(LS_TG) === 'true';

      function refreshStatusUI(){
        if(ytStatusEl) ytStatusEl.textContent = ytClaimed ? '✅ Claimed' : '❌ Click to subscribe';
        if(tgStatusEl) tgStatusEl.textContent = tgClaimed ? '✅ Claimed' : '❌ Click to subscribe';
      }
      refreshStatusUI();

      // helper: начисление награды (попытаемся вызвать существующую функцию updCoins/claimRewardFromModal если есть)
      function awardZex(amount){
        try{
          if (typeof window.updCoins === 'function') {
            window.updCoins(amount);
            return;
          }
        }catch(e){}
        // fallback — манипуляция localStorage и UI
        try{
          const key = 'coins';
          const cur = +localStorage.getItem(key) || 0;
          localStorage.setItem(key, String(cur + amount));
          const coinsEl = document.getElementById('coinsVal');
          if(coinsEl) coinsEl.textContent = (typeof window.format === 'function') ? window.format(cur + amount) : String(cur + amount);
          // также увеличиваем TON пропорционально, если в проекте такая логика
          const tonKey = 'ton';
          const curTon = +localStorage.getItem(tonKey) || 0;
          const additionTon = amount * (window.ZEX_TO_TON || 0.000001);
          localStorage.setItem(tonKey, String(curTon + additionTon));
          const tonEl = document.getElementById('tonVal');
          if(tonEl) tonEl.textContent = (typeof window.formatTon === 'function') ? window.formatTon(curTon + additionTon) : (curTon + additionTon).toFixed(2);
        }catch(e){ console.error('awardZex fallback failed', e); }
      }

      // обработчики кнопок (они уже присутствуют в разметке)
      const claimYTBtn = document.getElementById('claimYT');
      const claimTGBtn = document.getElementById('claimTG');

      if(claimYTBtn){
        claimYTBtn.addEventListener('click', ()=>{
          if(ytClaimed){ alert('YouTube quest уже выполнен'); return; }
          // открываем канал в новой вкладке
          window.open('https://youtube.com/@xtrade_x?si=tKd8E9i81tv32I36', '_blank', 'noopener');
          // начисляем награду и фиксируем состояние
          ytClaimed = true;
          localStorage.setItem(LS_YT, 'true');
          awardZex(YT_REWARD);
          refreshStatusUI();
          alert('Награда за YouTube выдана: +' + YT_REWARD + ' ZEX');
        });
      }

      if(claimTGBtn){
        claimTGBtn.addEventListener('click', ()=>{
          if(tgClaimed){ alert('Telegram quest уже выполнен'); return; }
          // открываем телеграм-канал
          window.open('https://t.me/x_trade_news', '_blank', 'noopener');
          // начисляем награду и фиксируем состояние
          tgClaimed = true;
          localStorage.setItem(LS_TG, 'true');
          awardZex(TG_REWARD);
          refreshStatusUI();
          alert('Награда за Telegram выдана: +' + TG_REWARD + ' ZEX');
        });
      }

      // если нужно — можно автоматически синхронизовать основной отображаемый баланс с локальным хранилищем
      function syncBalancesFromStorage(){
        try{
          const coinsKey = 'coins';
          const tonKey = 'ton';
          const coinsEl = document.getElementById('coinsVal');
          const tonEl = document.getElementById('tonVal');
          const c = +localStorage.getItem(coinsKey) || 0;
          const t = +localStorage.getItem(tonKey) || 0;
          if(coinsEl) coinsEl.textContent = (typeof window.format === 'function') ? window.format(c) : String(c);
          if(tonEl) tonEl.textContent = (typeof window.formatTon === 'function') ? window.formatTon(t) : (t).toFixed(2);
        }catch(e){}
      }
      // initial sync
      syncBalancesFromStorage();

    })();
  </script>
</body>
</html>
