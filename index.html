<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Hide & Seek ‚Äî Mini Games Style</title>
  <style>
:root{
  /* palette inspired by playful mini-games (Hamster Combat, Not Coin) */
  --bg-1: #0f1226; /* deep night */
  --bg-2: linear-gradient(120deg,#11162b,#1b2138);
  --card: linear-gradient(180deg,#161a33,#1f2540);
  --accent-1: #ff6b6b; /* coral */
  --accent-2: #ffd166; /* warm yellow */
  --accent-3: #6be6ff; /* cyan */
  --muted: #cbd5ff;
  --glass-weak: rgba(255,255,255,0.03);
  --glass-strong: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.00));
  --text: #eef6ff;
  --success: #7cff7c;
  --danger: #ff5a8a;
}
html,body{height:100%;margin:0;padding:0;font-family:Inter, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial; background:var(--bg-2);color:var(--text);}
body{display:flex;flex-direction:column;align-items:center;min-height:100vh;gap:12px;padding:18px;}

/* Header playful */
header{width:100%;max-width:980px;display:flex;justify-content:space-between;align-items:center;padding:12px;border-radius:18px;background:linear-gradient(90deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));box-shadow:0 18px 40px rgba(4,8,20,0.7);border:1px solid rgba(255,255,255,0.02)}
.energy-panel{display:flex;align-items:center;gap:10px;padding:10px 12px;border-radius:12px;background:linear-gradient(90deg, rgba(255,255,255,0.02), rgba(255,255,255,0.00));border:1px solid rgba(255,255,255,0.02);}
.energy-panel .icon{font-size:20px}
.energy-panel .val{font-weight:900;font-size:16px;color:var(--accent-3)}
.energy-panel .timer{font-size:12px;color:var(--muted)}

.coin-panel{display:flex;align-items:center;gap:12px;padding:8px;border-radius:12px;background:transparent}
.coin-logo{width:44px;height:44px;border-radius:50%;overflow:hidden;background:linear-gradient(135deg,var(--accent-1),var(--accent-3));display:flex;align-items:center;justify-content:center;border:3px solid rgba(255,255,255,0.06);}
.coin-logo img{width:72%;height:72%;object-fit:contain}
.ton-logo{width:40px;height:40px;border-radius:50%;background:linear-gradient(135deg,var(--accent-2),#ffd9a8);display:flex;align-items:center;justify-content:center;border:3px solid rgba(255,255,255,0.06)}
.coin-panel .val{font-weight:900;font-size:16px}

/* House grid ‚Äî chunkier, playful tiles */
.house{position:relative;width:100%;max-width:980px;display:grid;grid-template-columns:repeat(4,1fr);grid-auto-rows:120px;gap:14px;margin-top:8px}
.room{background:var(--card);border-radius:14px;display:flex;align-items:center;justify-content:center;font-weight:900;font-size:24px;color:var(--text);cursor:pointer;transition:transform .18s,box-shadow .18s,border-color .18s;padding:12px;box-shadow:0 10px 30px rgba(2,6,20,0.6);border:2px solid rgba(255,255,255,0.02)}
.room:hover{transform:translateY(-6px);box-shadow:0 22px 48px rgba(0,0,0,0.65)}
.room.selected{border-color:var(--accent-3);box-shadow:0 0 28px rgba(107,230,255,0.12)}
.room.found{border-color:var(--danger);box-shadow:0 0 22px rgba(255,90,138,0.14);animation:shake .8s}
.room.safe{border-color:var(--success);box-shadow:0 0 22px rgba(124,255,124,0.12);transform:scale(1.02)}
.room.highlight{box-shadow:0 0 40px 12px rgba(255,107,107,0.06);transform:scale(1.03)}
@keyframes shake{0%{transform:translateX(0)}25%{transform:translateX(-6px)}50%{transform:translateX(6px)}75%{transform:translateX(-4px)}100%{transform:translateX(0)}}

/* Controls big playful buttons */
.controls{width:100%;max-width:980px;display:flex;gap:12px;justify-content:center}
.btnPrimary{flex:1;padding:14px 18px;border-radius:14px;border:none;background:linear-gradient(90deg,var(--accent-1),var(--accent-3));color:#071023;font-weight:900;font-size:18px;box-shadow:0 16px 36px rgba(255,107,107,0.12);cursor:pointer}
.btnGhost{flex:1;padding:12px 16px;border-radius:14px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--muted);font-weight:800;cursor:pointer}

/* Upgrades horizontal scroller */
.upgrade-panel{width:100%;max-width:980px;display:flex;gap:12px;overflow-x:auto;padding:12px}
.upgrade{min-width:200px;background:linear-gradient(180deg,#1a1530,#24183f);border-radius:12px;padding:12px;border:1px solid rgba(255,255,255,0.03);box-shadow:0 8px 30px rgba(2,6,20,0.6)}
.upgrade h3{color:var(--accent-2);font-size:15px;margin:0 0 6px}
.upgrade .price{font-weight:900;color:var(--muted)}

/* Mining info */
.mining-info{width:100%;max-width:980px;padding:12px;border-radius:12px;background:linear-gradient(90deg, rgba(255,255,255,0.02), rgba(255,255,255,0.00));border:1px solid rgba(255,255,255,0.03);display:flex;justify-content:space-between;align-items:center}

/* Bottom menu floating */
.bottom-menu{position:fixed;bottom:22px;left:50%;transform:translateX(-50%);display:flex;gap:10px;background:linear-gradient(90deg,#111426,#1b2034);padding:10px;border-radius:999px;box-shadow:0 18px 50px rgba(2,6,20,0.7);border:1px solid rgba(255,255,255,0.03)}
.bottom-menu button{background:transparent;border:none;color:var(--muted);font-size:20px;padding:10px;border-radius:10px;cursor:pointer}
.bottom-menu button:hover{color:var(--text);transform:translateY(-4px)}

/* Modals styling more playful */
.withdraw-modal,.casino-modal,#miningShop,#infoWindow,#profileWindow,#wsModalOverlay{display:none;position:fixed;inset:0;z-index:9999;align-items:center;justify-content:center;padding:20px}
.withdraw-card,.casino-modal .card,.content,#wsModalOverlay .glass{width:100%;max-width:920px;border-radius:18px;padding:18px;background:linear-gradient(180deg,#0f1530,#151a35);border:2px solid rgba(255,255,255,0.03);box-shadow:0 30px 80px rgba(0,0,0,0.7)}
.close-top{position:absolute;right:18px;top:18px;background:transparent;border:none;color:var(--muted);font-size:20px}

/* Wheel canvas responsive */
.wheel-wrap{width:360px;height:360px}
#wheelCanvas{width:100%;height:100%;border-radius:50%;}

/* Mining shop small cards */
.miner-card{background:linear-gradient(180deg,#151a33,#17203b);border-radius:12px;padding:12px;display:flex;flex-direction:column;align-items:center;gap:8px;border:1px solid rgba(255,255,255,0.03)}
.card-logo{width:56px;height:56px;border-radius:50%;border:3px solid #fff;background:#fff;object-fit:cover}

/* Responsive tweaks */
@media (max-width:880px){ .house{grid-template-columns:repeat(2,1fr);grid-auto-rows:120px} }
@media (max-width:520px){ .house{grid-auto-rows:100px} .btnPrimary{font-size:16px;padding:12px} }
  </style>
</head>
<body>
  <header>
    <div class="energy-panel" id="energyPanel" aria-live="polite" aria-atomic="true">
      <div class="icon">‚ö°</div>
      <div style="display:flex;flex-direction:column;align-items:flex-start;">
        <div style="font-size:12px;color:var(--muted);font-weight:800">Energy</div>
        <div style="display:flex;align-items:center;gap:8px;">
          <div class="val" id="energyVal">50</div>
          <div class="timer" id="energyTimer">‚Äî</div>
        </div>
      </div>
    </div>

    <div class="coin-panel" aria-live="polite" aria-atomic="true">
      <div style="display:flex;align-items:center;gap:8px;">
        <div class="coin-logo" title="XTR">
          <img src="logo.png" alt="XTR logo" />
        </div>
        <div style="display:flex;flex-direction:column;align-items:flex-end;line-height:1;">
          <div style="font-size:11px;color:var(--muted);font-weight:800">XTR</div>
          <div class="val" id="coinsVal">0</div>
        </div>
      </div>
       <div class="ton-panel" style="margin-left:6px;display:flex;align-items:center;gap:8px;">
        <div class="ton-logo" title="TON">
          <img src="ton.png" alt="TON logo" />
        </div>
        <div style="display:flex;flex-direction:column;align-items:flex-end;line-height:1;">
          <div style="font-size:11px;color:var(--muted);font-weight:800">TON</div>
          <div class="ton-val" id="tonVal">0.00</div>
        </div>
      </div>
    </div>
  </header>

  <div class="house"></div>

  <div class="controls">
    <button id="startBtn" class="btnPrimary">üè† Start</button>
    <button id="resetBtn" class="btnGhost">üîç Hunt</button>
  </div>

  <div class="upgrade-panel" id="upgradePanel"></div>

  <div class="mining-info">
    <strong id="miningLabel">Mining Income:</strong> <span id="miningIncomeVal">0</span>/hr
    <div style="margin-left:auto;font-weight:900;color:var(--muted);">Balance: <span id="miniBalance">0 XTR</span></div>
  </div>

  <div id="miningShop"></div>

  <div id="buyConfirm"></div>

  <div id="infoWindow"></div>
  <div id="profileWindow"></div>

  <div class="bottom-menu">
    <button id="infoBtn" class="btnGhost">‚Ñπ</button>
    <button id="miningBtn" class="btnGhost">‚õè</button>
    <button id="profileBtn" class="btnGhost">üë§</button>
    <button id="withdrawBtn" class="btnGhost" title="–í—ã–≤–æ–¥">üí∏</button>
    <button id="casinoBtn" class="btnGhost" title="Casino">üé∞</button>
  </div>

  <!-- Rewards modal simplified placeholder (will be opened by JS) -->
  <div id="wsModalOverlay" aria-hidden="false">
    <div class="glass">
      <div class="header">
        <div class="title">
          <div class="coinIcon">üíé</div>
          <div>
            <div id="wsTitle">Premium Gifts</div>
            <div class="sub">7 days of rewards ‚Äî claim one per day</div>
          </div>
        </div>
        <div style="text-align:right">
          <div id="wsModalCoinsDisplay">0 XTR ‚Ä¢ 0.00 TON</div>
          <div style="font-size:12px;color:var(--muted)">Coins balance</div>
        </div>
      </div>
      <div class="rewardsShell" id="rewardsShell">
        <div class="rewardsContainer" id="rewardsContainer">
          <div class="rewardsGridTop" id="rewardsGridTop"></div>
          <div style="height:8px"></div>
          <div class="rewardsGridBottom" id="rewardsGridBottom"></div>
          <div class="wsActions">
            <div class="left">Unlocked: <span id="wsUnlockedCount">0</span>/7</div>
            <div style="display:flex;gap:10px">
              <button class="btnGhost" id="wsBtnRules">How it works</button>
              <button class="btnPrimarySmall btnPrimary" id="wsBtnClose" style="padding:8px 12px;">Come back tomorrow</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Casino modal core elements (JS will populate) -->
  <div id="casinoModal" class="casino-modal" aria-hidden="true">
    <div class="card">
      <div class="casino-header">
        <div>
          <div id="casinoTitle">üé∞ –ö–∞–∑–∏–Ω–æ</div>
          <div id="casinoSubtitle" style="color:var(--muted);font-weight:700">Spin the wheel ‚Äî once every 2 hours</div>
        </div>
        <div id="casinoBalance" style="text-align:right;font-weight:800;color:var(--accent-3)">0 XTR ‚Ä¢ 0.00 TON</div>
      </div>
      <div class="casino-body" style="display:flex;gap:18px;align-items:center;flex-wrap:wrap;justify-content:center">
        <div class="wheel-wrap">
          <canvas id="wheelCanvas" width="800" height="800"></canvas>
          <div class="wheel-pointer" style="position:absolute;top:-8px;left:50%;transform:translateX(-50%);width:0;height:0;border-left:14px solid transparent;border-right:14px solid transparent;border-bottom:26px solid #fff;filter:drop-shadow(0 6px 18px rgba(0,0,0,0.28))"></div>
        </div>
        <div class="casino-controls" style="display:flex;flex-direction:column;gap:8px;min-width:220px">
          <div class="casino-note">Next spin in: <span id="casinoCooldown">Ready</span></div>
          <button id="spinBtn" class="spin-btn btnPrimary" style="padding:12px 18px;border-radius:12px;">SPIN</button>
          <div>Result: <span id="casinoResult">‚Äî</span></div>
          <button id="closeCasino" class="btnGhost" style="padding:8px 12px;border-radius:10px;">Close</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Withdraw modal simplified -->
  <div id="withdrawModal" class="withdraw-modal" aria-hidden="true">
    <div class="withdraw-card">
      <div class="withdraw-header" style="display:flex;justify-content:space-between;align-items:center;">
        <div class="title" style="display:flex;align-items:center;gap:12px">
          <div class="icon" style="width:44px;height:44px;border-radius:12px;background:linear-gradient(90deg,var(--accent-3),var(--accent-2));display:flex;align-items:center;justify-content:center;color:#071023;font-weight:900">üí∏</div>
          <div>
            <div style="font-size:18px;font-weight:900">–í—ã–≤–æ–¥ —Å—Ä–µ–¥—Å—Ç–≤</div>
            <div style="font-size:13px;color:var(--muted)">–ü–ª–∞—Ç–µ–∂–∏ –ø—Ä–æ—Ö–æ–¥—è—Ç —á–µ—Ä–µ–∑ TON</div>
          </div>
        </div>
        <div style="font-size:13px;color:var(--muted);">–î–æ–≤–µ—Ä–∏–µ: –≤—ã–ø–ª–∞—Ç—ã –æ—Ñ–æ—Ä–º–ª—è—é—Ç—Å—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º</div>
      </div>

      <div style="font-size:13px;color:var(--muted);margin-top:8px;">–í—Å–µ —Ç–æ–∫–µ–Ω—ã –±—É–¥—É—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã –Ω–∞ —É–∫–∞–∑–∞–Ω–Ω—ã–π –≤—ã—à–µ –∞–¥—Ä–µ—Å –≤ –¥–∞—Ç—É –ª–∏—Å—Ç–∏–Ω–≥–∞ –º–æ–Ω–µ—Ç—ã ‚Äî <strong>15 –¥–µ–∫–∞–±—Ä—è 2025</strong>.</div>

      <div class="withdraw-body" style="display:grid;grid-template-columns:1fr;gap:14px;margin-top:12px;">
        <div class="withdraw-section" aria-label="address-section">
          <div class="sec-title">üì´ –ê–¥—Ä–µ—Å –¥–ª—è –≤—ã–ø–ª–∞—Ç</div>
          <div class="sec-desc">–£–∫–∞–∂–∏—Ç–µ TON-–∞–¥—Ä–µ—Å. –ü–æ—Å–ª–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∞–¥—Ä–µ—Å –±—É–¥–µ—Ç –ø—Ä–∏–≤—è–∑–∞–Ω.</div>

          <input id="withdrawAddressInput" class="addr-input" placeholder="UQ..." aria-label="TON address input" style="width:100%;padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--text);font-weight:800" />
          <div style="display:flex;gap:8px;align-items:center;margin-top:8px;">
            <button id="saveWithdrawAddr" class="btnPrimary">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
            <button id="changeWithdrawAddr" class="btnGhost">–°–º–µ–Ω–∏—Ç—å</button>
            <button id="copyAddrBtn" class="btnGhost" style="margin-left:auto;">–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å</button>
          </div>
          <div id="boundAddrInfo" class="small-note" style="margin-top:8px;color:var(--muted)"></div>
          <div id="withdrawStatus" class="withdraw-warning" style="margin-top:8px;padding:8px;border-radius:8px;background:rgba(255,165,0,0.03);border:1px solid rgba(255,165,0,0.04);color:#ffdb9c;font-weight:700">–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∞–¥—Ä–µ—Å</div>
        </div>
      </div>

      <div style="display:flex;justify-content:flex-end;margin-top:12px;">
        <button id="closeWithdraw" class="btnGhost">–ó–∞–∫—Ä—ã—Ç—å</button>
      </div>
    </div>
  </div>

<script>
  /* Combined JS (from user) ‚Äî merged and left logic intact. Some UI elements were reorganized above. */

  // ======= Constants & storage keys =======
  const LS_COINS = 'coins';
  const LS_MAXCOINS = 'maxCoins';
  const LS_UPGRADES = 'upgrades';
  const LS_MINERS = 'minersState';
  const LS_LASTTIME = 'lastTime';
  const LS_TON = 'player_ton_v1';
  const LS_WITHDRAW_ADDR = 'player_withdraw_ton_addr_v1';
  const LS_WITHDRAW_LOG = 'player_withdraw_log_v1';

  // Conversion: 1 XTR -> 0.000001 TON  (so 1000 XTR = 0.001 TON)
  const ZEX_TO_TON = 0.000001;
  const TON_TO_ZEX = 1 / ZEX_TO_TON; // 1 TON = 1,000,000 XTR

  // ========== Localization ==========
  const i18n = {
  ru: {
    pickRoomFirst: '–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ –∫–æ–º–Ω–∞—Ç—É!',
    notEnough: '–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –º–æ–Ω–µ—Ç!',
    dailyAlready: '–ï–∂–µ–¥–Ω–µ–≤–Ω–∞—è –Ω–∞–≥—Ä–∞–¥–∞ —É–∂–µ –ø–æ–ª—É—á–µ–Ω–∞!',
    questAlready: '–ö–≤–µ—Å—Ç —É–∂–µ –≤—ã–ø–æ–ª–Ω–µ–Ω!',
    miningIncome: '–î–æ—Ö–æ–¥ –º–∞–π–Ω–∏–Ω–≥–∞:',
    miningShop: '–ú–∞–≥–∞–∑–∏–Ω –º–∞–π–Ω–∏–Ω–≥–∞',
    close: '–ó–∞–∫—Ä—ã—Ç—å',
    howToPlay: '–ö–∞–∫ –∏–≥—Ä–∞—Ç—å',
    infoList: [
      '–í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–º–Ω–∞—Ç—É, –∑–∞—Ç–µ–º –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É üîç –¥–ª—è –æ—Ö–æ—Ç—ã.',
      '–û—Ö–æ—Ç–Ω–∏–∫ –∏—â–µ—Ç 2 —Å–ª—É—á–∞–π–Ω—ã–µ –∫–æ–º–Ω–∞—Ç—ã (1, –µ—Å–ª–∏ –∞–∫—Ç–∏–≤–µ–Ω "Check 1 Room").',
      '–ï—Å–ª–∏ –≤–∞—à—É –∫–æ–º–Ω–∞—Ç—É –Ω–∞—à–ª–∏, –≤—ã —Ç–µ—Ä—è–µ—Ç–µ –º–æ–Ω–µ—Ç—ã (–ø–æ–∫–∞–∑—ã–≤–∞—é—Ç—Å—è –∫—Ä–∞—Å–Ω—ã–º).',
      '–ï—Å–ª–∏ –≤—ã –∏–∑–±–µ–∂–∞–ª–∏ –æ—Ö–æ—Ç—ã, –≤—ã –ø–æ–ª—É—á–∞–µ—Ç–µ –º–æ–Ω–µ—Ç—ã (–ø–æ–∫–∞–∑—ã–≤–∞—é—Ç—Å—è –∑–µ–ª–µ–Ω—ã–º).',
      '–ü–æ–∫—É–ø–∞–π—Ç–µ –∞–ø–≥—Ä–µ–π–¥—ã –∏–ª–∏ –º–∞–π–Ω–µ—Ä–æ–≤, —á—Ç–æ–±—ã —É–ª—É—á—à–∏—Ç—å —à–∞–Ω—Å—ã –∏ –¥–æ—Ö–æ–¥.',
      '–ó–∞–±–∏—Ä–∞–π—Ç–µ –µ–∂–µ–¥–Ω–µ–≤–Ω—ã–µ –Ω–∞–≥—Ä–∞–¥—ã –∏ –≤—ã–ø–æ–ª–Ω—è–π—Ç–µ –∫–≤–µ—Å—Ç—ã –¥–ª—è –±–æ–Ω—É—Å–Ω—ã—Ö –º–æ–Ω–µ—Ç.'
    ],
    profile: '–ü—Ä–æ—Ñ–∏–ª—å',
    dailyReward: '–ï–∂–µ–¥–Ω–µ–≤–Ω–∞—è –Ω–∞–≥—Ä–∞–¥–∞',
    dailyText: '–ü–æ–ª—É—á–∏—Ç–µ 30 000 XTR —Ä–∞–∑ –≤ –¥–µ–Ω—å!',
    claimDaily: '–ó–∞–±—Ä–∞—Ç—å',
    quest: '–ö–≤–µ—Å—Ç',
    claimQuest: '–í–∑—è—Ç—å',
    settings: '–ù–∞—Å—Ç—Ä–æ–π–∫–∏',
    settingsText: '–°–º–µ–Ω–∏—Ç–µ —è–∑—ã–∫ –∏ –¥—Ä—É–≥–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã.',
    buyFor: '–ö—É–ø–∏—Ç—å {name} –∑–∞ {price}?',
    buy: '–ö—É–ø–∏—Ç—å',
    cancel: '–û—Ç–º–µ–Ω–∞',
    profitHr: '–ü—Ä–∏–±—ã–ª—å/—á:',
    noEnergy: '–ù–µ—Ç —ç–Ω–µ—Ä–≥–∏–∏!',
    startBtn: 'üè† –ù–∞—á–∞—Ç—å',
    resetBtn: 'üîç –û—Ö–æ—Ç–∞',
    wsTitle: '–ü—Ä–µ–º–∏—É–º –ø–æ–¥–∞—Ä–∫–∏',
    wsSub: '7 –¥–Ω–µ–π –Ω–∞–≥—Ä–∞–¥ ‚Äî –∑–∞–±–∏—Ä–∞–π—Ç–µ –ø–æ –æ–¥–Ω–æ–º—É –≤ –¥–µ–Ω—å',
    wsBtnClose: '–í–µ—Ä–Ω—É—Ç—å—Å—è –∑–∞–≤—Ç—Ä–∞',
    wsBtnRules: '–ö–∞–∫ —ç—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç',
    dayLabel: '–î–µ–Ω—å',
    claimed: '–ó–∞–±—Ä–∞–Ω–æ',
    casinoTitle: 'üé∞ –ö–∞–∑–∏–Ω–æ',
    casinoSubtitle: '–í—Ä–∞—â–∞–π—Ç–µ –∫–æ–ª–µ—Å–æ ‚Äî —Ä–∞–∑ –≤ 2 —á–∞—Å–∞',
    spin: '–ö–†–£–¢–ò–¢–¨',
    ready: '–ì–æ—Ç–æ–≤–æ',
    full: '–ü–æ–ª–Ω—ã–π',
    coinsBalance: '–ë–∞–ª–∞–Ω—Å –º–æ–Ω–µ—Ç'
  },
  en: {
    pickRoomFirst: 'Pick a room first!',
    notEnough: 'Not enough coins!',
    dailyAlready: 'Daily reward already claimed!',
    questAlready: 'Quest already claimed!',
    miningIncome: 'Mining Income:',
    miningShop: 'Mining Shop',
    close: 'Close',
    howToPlay: 'How to Play',
    infoList: [
      'Select a room and then click the üîç button to hunt.',
      'The hunter searches 2 random rooms (1 if "Check 1 Room" is active).',
      'If your room is found, you lose coins (shown in red).',
      'If you evade the hunt, you gain coins (shown in green).',
      'Buy upgrades or miners to improve your chances and income.',
      'Claim daily rewards and complete quests for bonus coins.'
    ],
    profile: 'Profile',
    dailyReward: 'Daily Reward',
    dailyText: 'Get 30,000 XTR once a day!',
    claimDaily: 'Claim Daily',
    quest: 'Quest',
    claimQuest: 'Claim Quest',
    settings: 'Settings',
    settingsText: 'Change language and other preferences.',
    buyFor: 'Buy {name} for {price}?',
    buy: 'Buy',
    cancel: 'Cancel',
    profitHr: 'Profit/hr:',
    noEnergy: 'No energy!',
    startBtn: 'üè† Start',
    resetBtn: 'üîç Hunt',
    wsTitle: 'Premium Gifts',
    wsSub: '7 days of rewards ‚Äî claim one per day',
    wsBtnClose: 'Come back tomorrow',
    wsBtnRules: 'How it works',
    dayLabel: 'Day',
    claimed: 'Claimed',
    casinoTitle: 'üé∞ Casino',
    casinoSubtitle: 'Spin the wheel ‚Äî once every 2 hours',
    spin: 'SPIN',
    ready: 'Ready',
    full: 'Full',
    coinsBalance: 'Coins balance'
  } };
  let lang = localStorage.getItem('lang') || 'ru';
  function t(key, vars = {}) {
    const val = i18n[lang] && i18n[lang][key];
    if (typeof val === 'string') {
      return val.replace(/\{(\w+)\}/g, (_, k) => vars[k] || '');
    }
    return val || '';
  }
  function applyLang() {
    // UI pieces translated
    document.getElementById('miningLabel') && (document.getElementById('miningLabel').textContent = t('miningIncome'));
    document.getElementById('shopTitle') && (document.getElementById('shopTitle').textContent = t('miningShop'));
    document.getElementById('closeMiningShop') && (document.getElementById('closeMiningShop').textContent = t('close'));
    const cb = document.getElementById('confirmBuy'); const canc = document.getElementById('cancelBuy');
    if (cb) cb.textContent = t('buy');
    if (canc) canc.textContent = t('cancel');
    document.getElementById('infoTitle') && (document.getElementById('infoTitle').textContent = t('howToPlay'));
    document.getElementById('profileTitle') && (document.getElementById('profileTitle').textContent = t('profile'));
    document.getElementById('dailyTitle') && (document.getElementById('dailyTitle').textContent = t('dailyReward'));
    document.getElementById('dailyText') && (document.getElementById('dailyText').textContent = t('dailyText'));
    document.getElementById('claimDaily') && (document.getElementById('claimDaily').textContent = t('claimDaily'));
    document.getElementById('questTitle') && (document.getElementById('questTitle').textContent = t('quest'));
    document.getElementById('claimQuest') && (document.getElementById('claimQuest').textContent = t('claimQuest'));
    document.getElementById('settingsTitle') && (document.getElementById('settingsTitle').textContent = t('settings'));
    document.getElementById('settingsText') && (document.getElementById('settingsText').textContent = t('settingsText'));

    // Info list
    const infoListEl = document.getElementById('infoList');
    if (infoListEl) {
      infoListEl.innerHTML = '';
      (t('infoList') || []).forEach(li => { const el = document.createElement('li'); el.textContent = li; infoListEl.appendChild(el); });
    }

    // TG claim button (profile)
    const claimTgBtn = document.getElementById('claimTgSubscribe');
    if (claimTgBtn) claimTgBtn.textContent = t('claimQuest');

    // Start / Hunt buttons
    const startBtn = document.getElementById('startBtn');
    if (startBtn) startBtn.textContent = t('startBtn');
    const resetBtn = document.getElementById('resetBtn');
    if (resetBtn) resetBtn.textContent = t('resetBtn');

    // Rewards modal title/sub/buttons
    const wsTitleEl = document.getElementById('wsTitle');
    if (wsTitleEl) wsTitleEl.textContent = t('wsTitle');
    const wsSubEl = document.querySelector('#wsModalOverlay .sub');
    if (wsSubEl) wsSubEl.textContent = t('wsSub');
    const btnClose = document.getElementById('wsBtnClose');
    if (btnClose) btnClose.textContent = t('wsBtnClose');
    const btnRules = document.getElementById('wsBtnRules');
    if (btnRules) btnRules.textContent = t('wsBtnRules');

    // Casino translations
    const casinoTitleEl = document.getElementById('casinoTitle');
    if (casinoTitleEl) casinoTitleEl.textContent = t('casinoTitle');
    const casinoSubtitleEl = document.getElementById('casinoSubtitle');
    if (casinoSubtitleEl) casinoSubtitleEl.textContent = t('casinoSubtitle');
    const spinBtn = document.getElementById('spinBtn');
    if (spinBtn) spinBtn.textContent = t('spin');

    // Update coins balance label if exists
    const coinsBalanceCaption = document.querySelector('#wsModalOverlay .header div:last-child div:last-child');
    if (coinsBalanceCaption) coinsBalanceCaption.textContent = t('coinsBalance');
  }

  // ========== Energy ==========
  const MAX_ENERGY = 50;
  const REGEN_INTERVAL_MS = 30 * 1000;
  const LS_ENERGY = 'player_energy_v1';
  const LS_ENERGY_TICK = 'player_energy_tick_v1';

  let energy;
  let energyLastTick;
  (function initEnergyStorage(){
    const raw = localStorage.getItem(LS_ENERGY);
    if (raw === null) {
      energy = MAX_ENERGY;
      energyLastTick = Date.now();
      try {
        localStorage.setItem(LS_ENERGY, String(energy));
        localStorage.setItem(LS_ENERGY_TICK, String(energyLastTick));
      } catch(e){}
    } else {
      energy = +raw;
      if (!Number.isFinite(energy)) energy = MAX_ENERGY;
      energyLastTick = +localStorage.getItem(LS_ENERGY_TICK) || Date.now();
    }
    if (energy >= MAX_ENERGY) energyLastTick = Date.now();
    try {
      localStorage.setItem(LS_ENERGY, String(energy));
      localStorage.setItem(LS_ENERGY_TICK, String(energyLastTick));
    } catch(e) { }
  })();

  function loadEnergy() {
    const stored = localStorage.getItem(LS_ENERGY);
    const storedTick = localStorage.getItem(LS_ENERGY_TICK);
    if (stored !== null) energy = +stored;
    if (!Number.isFinite(energy)) energy = MAX_ENERGY;
    energyLastTick = +storedTick || Date.now();

    const now = Date.now();
    if (now > energyLastTick && energy < MAX_ENERGY) {
      const delta = now - energyLastTick;
      const gained = Math.floor(delta / REGEN_INTERVAL_MS);
      if (gained > 0) {
        energy = Math.min(MAX_ENERGY, energy + gained);
        energyLastTick += gained * REGEN_INTERVAL_MS;
      }
    }
    if (energy >= MAX_ENERGY) energyLastTick = Date.now();
    saveEnergy();
    updateEnergyDisplay();
  }

  function saveEnergy() {
    try {
      localStorage.setItem(LS_ENERGY, String(energy));
      localStorage.setItem(LS_ENERGY_TICK, String(energyLastTick));
    } catch (e) { /* ignore */ }
  }

  function updateEnergyDisplay() {
    const el = document.getElementById('energyVal');
    const timerEl = document.getElementById('energyTimer');
    if (el) el.textContent = String(energy);
    if (timerEl) {
      if (energy >= MAX_ENERGY) {
        timerEl.textContent = t('full') || 'Full';
      } else {
        const now = Date.now();
        const delta = now - (energyLastTick || now);
        const rem = REGEN_INTERVAL_MS - (delta % REGEN_INTERVAL_MS);
        const secs = Math.ceil(rem / 1000);
        const mm = Math.floor(secs / 60);
        const ss = secs % 60;
        timerEl.textContent = `${mm>0?mm+'m ':''}${ss}s`;
      }
    }
  }

  function consumeEnergyOne() {
    const now = Date.now();
    if (now > energyLastTick && energy < MAX_ENERGY) {
      const delta = now - energyLastTick;
      const gained = Math.floor(delta / REGEN_INTERVAL_MS);
      if (gained > 0) {
        energy = Math.min(MAX_ENERGY, energy + gained);
        energyLastTick += gained * REGEN_INTERVAL_MS;
      }
    }
    if (energy <= 0) {
      alert(t('noEnergy'));
      return false;
    }
    energy = Math.max(0, energy - 1);
    if (energy < MAX_ENERGY && (!energyLastTick || energyLastTick < Date.now() - 24*3600*1000)) energyLastTick = Date.now();
    saveEnergy();
    updateEnergyDisplay();
    return true;
  }

  setInterval(()=> {
    const now = Date.now();
    if (energy >= MAX_ENERGY) {
      energyLastTick = now;
      saveEnergy();
      updateEnergyDisplay();
      return;
    }
    if (now - energyLastTick >= REGEN_INTERVAL_MS) {
      const gained = Math.floor((now - energyLastTick) / REGEN_INTERVAL_MS);
      if (gained > 0) {
        energy = Math.min(MAX_ENERGY, energy + gained);
        energyLastTick += gained * REGEN_INTERVAL_MS;
        if (energy >= MAX_ENERGY) energyLastTick = now;
        saveEnergy();
        updateEnergyDisplay();
      }
    } else {
      updateEnergyDisplay();
    }
  }, 1000);

  // ========== UI & State ==========
  const roomsContainer = document.querySelector('.house');
  for (let i = 0; i < 8; i++) {
    const d = document.createElement('div');
    d.className = 'room';
    d.dataset.idx = i;
    d.textContent = '+';
    roomsContainer.appendChild(d);
  }
  let selectedRoom = null;

  // coins (XTR) and ton are separate now
  let coins = +localStorage.getItem(LS_COINS) || 0;
  let maxCoins = +localStorage.getItem(LS_MAXCOINS) || coins;
  let ton = +localStorage.getItem(LS_TON) || 0; // TON stored independently

  const coinsVal = document.getElementById('coinsVal');
  let upgrades = JSON.parse(localStorage.getItem(LS_UPGRADES)) || { x2Prize: 0, check1: 0 };
  let check1Expire = +localStorage.getItem('check1Expire') || 0;
  let roundInProgress = false;

  let shieldExpire = +localStorage.getItem('shieldExpire') || 0;
  let doubleIncomeExpire = +localStorage.getItem('doubleIncomeExpire') || 0;
  let luckExpire = +localStorage.getItem('luckExpire') || 0;

  const minersData = [
    { n: "Miner 1", i: 500, p: 7000 },
    { n: "Miner 2", i: 1788, p: 12000 },
    { n: "Miner 3", i: 2358, p: 15000 },
    { n: "Miner 4", i: 3000, p: 20000 },
    { n: "Miner 5", i: 4500, p: 25000 },
    { n: "Miner 6", i: 5200, p: 30000 },
    { n: "Miner 7", i: 6100, p: 35000 },
    { n: "Miner 8", i: 7200, p: 40000 },
    { n: "Miner 9", i: 8500, p: 45000 },
    { n: "Miner 10", i: 9500, p: 50000 }
  ];

  let minersState;
  try {
    const saved = JSON.parse(localStorage.getItem(LS_MINERS));
    if (Array.isArray(saved)) {
      minersState = minersData.map((_, i) => {
        const s = saved[i];
        if (s && typeof s.count === 'number') return { count: s.count };
        return { count: 0 };
      });
    } else {
      minersState = minersData.map(_ => ({ count: 0 }));
    }
  } catch (e) {
    minersState = minersData.map(_ => ({ count: 0 }));
  }

  const miningIncomeValEl = document.getElementById('miningIncomeVal');
  const minersContainerEl = document.querySelector('.miners-container');
  const minersPanelVisible = document.getElementById('minersPanelVisible');
  const miningShop = document.getElementById('miningShop');
  const buyConfirm = document.getElementById('buyConfirm');
  const buyText = document.getElementById('buyText');
  let pendingMiner = null;

  function format(n) {
    return n >= 1e9 ? (n/1e9).toFixed(1).replace(/\.0$/,'') + 'B' :
           n >= 1e6 ? (n/1e6).toFixed(1).replace(/\.0$/,'') + 'M' :
           n >= 1e3 ? (n/1e3).toFixed(1).replace(/\.0$/,'') + 'K' : String(n);
  }

  // TON formatting: always 2 decimals
  function formatTon(n){
    if (!isFinite(n)) return '0.00';
    return Number(n).toFixed(2);
  }
  // expose globally so other modules inside page can use
  window.formatTon = formatTon;

  function save() {
    try {
      localStorage.setItem(LS_COINS, String(coins));
      localStorage.setItem(LS_MAXCOINS, String(maxCoins));
      localStorage.setItem(LS_UPGRADES, JSON.stringify(upgrades));
      localStorage.setItem('check1Expire', check1Expire);
      localStorage.setItem(LS_MINERS, JSON.stringify(minersState));
      localStorage.setItem(LS_LASTTIME, Date.now());
      localStorage.setItem('lang', lang);
      localStorage.setItem('shieldExpire', shieldExpire);
      localStorage.setItem('doubleIncomeExpire', doubleIncomeExpire);
      localStorage.setItem('luckExpire', luckExpire);
      localStorage.setItem(LS_TON, String(ton));
    } catch (e) {
      console.warn('Save failed', e);
    }
  }

 // ========== Withdraw UI implementation (simplified) ==========
  (function(){
    const withdrawBtn = document.getElementById('withdrawBtn');
    const withdrawModal = document.getElementById('withdrawModal');
    const withdrawInput = document.getElementById('withdrawAddressInput');
    const saveAddrBtn = document.getElementById('saveWithdrawAddr');
    const changeAddrBtn = document.getElementById('changeWithdrawAddr');
    const copyAddrBtn = document.getElementById('copyAddrBtn');
    const boundInfo = document.getElementById('boundAddrInfo');
    const withdrawStatus = document.getElementById('withdrawStatus');
    const closeWithdraw = document.getElementById('closeWithdraw');

    function loadBoundAddr(){ return localStorage.getItem(LS_WITHDRAW_ADDR) || ''; }
    function saveBoundAddr(addr){ try{ localStorage.setItem(LS_WITHDRAW_ADDR, addr); }catch(e){} }
    function maskAddr(a){ if(!a) return ''; if(a.length <= 10) return a; return a.slice(0,6) + '...' + a.slice(-6); }

    function renderBoundInfo(){
      const a = loadBoundAddr();
      if(a){
        boundInfo.textContent = '–ü—Ä–∏–≤—è–∑–∞–Ω–Ω—ã–π –∞–¥—Ä–µ—Å: ' + maskAddr(a);
        if(withdrawInput) withdrawInput.style.display = 'none';
        if(saveAddrBtn) saveAddrBtn.style.display = 'none';
        if(changeAddrBtn) changeAddrBtn.style.display = 'inline-block';
        if(copyAddrBtn) copyAddrBtn.style.display = 'inline-block';
      } else {
        boundInfo.textContent = '–ê–¥—Ä–µ—Å –Ω–µ –ø—Ä–∏–≤—è–∑–∞–Ω.';
        if(withdrawInput) withdrawInput.style.display = 'block';
        if(saveAddrBtn) saveAddrBtn.style.display = 'inline-block';
        if(changeAddrBtn) changeAddrBtn.style.display = 'none';
        if(copyAddrBtn) copyAddrBtn.style.display = 'none';
      }
    }

    function openWithdraw(){
      if (!withdrawModal) return;
      withdrawModal.style.display = 'flex';
      withdrawModal.setAttribute('aria-hidden','false');
      renderBoundInfo();
      updateWithdrawStatus();
    }

    function closeWithdrawModal(){
      if (!withdrawModal) return;
      withdrawModal.style.display = 'none';
      withdrawModal.setAttribute('aria-hidden','true');
    }

    if (withdrawBtn) withdrawBtn.addEventListener('click', openWithdraw);
    if (closeWithdraw) closeWithdraw.addEventListener('click', closeWithdrawModal);

    if (saveAddrBtn) saveAddrBtn.addEventListener('click', ()=>{
      const v = (withdrawInput.value || '').trim();
      if(!v){ alert('–í–≤–µ–¥–∏—Ç–µ –∞–¥—Ä–µ—Å'); return; }
      saveBoundAddr(v);
      renderBoundInfo();
      if(withdrawStatus) withdrawStatus.textContent = '–ê–¥—Ä–µ—Å —Å–æ—Ö—Ä–∞–Ω—ë–Ω.';
      save();
    });

    if (changeAddrBtn) changeAddrBtn.addEventListener('click', ()=>{ 
      if(withdrawInput) withdrawInput.style.display = 'block';
      if(withdrawInput) withdrawInput.value = '';
      if(saveAddrBtn) saveAddrBtn.style.display = 'inline-block';
      if(changeAddrBtn) changeAddrBtn.style.display = 'none';
      if(copyAddrBtn) copyAddrBtn.style.display = 'none';
      if(boundInfo) boundInfo.textContent = '–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—ã–π –∞–¥—Ä–µ—Å.';
    });

    if (copyAddrBtn) copyAddrBtn.addEventListener('click', ()=>{
      const a = loadBoundAddr();
      if(!a) return;
      navigator.clipboard && navigator.clipboard.writeText(a).then(()=>{ if(withdrawStatus) withdrawStatus.textContent = '–ê–¥—Ä–µ—Å —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω.'; }).catch(()=>{ if(withdrawStatus) withdrawStatus.textContent = '–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å.'; });
    });

    function updateWithdrawStatus(){
      const currentTon = +localStorage.getItem(LS_TON) || ton || 0;
      if(!withdrawStatus) return;
      if(currentTon >= 7){ withdrawStatus.className = 'withdraw-success'; withdrawStatus.textContent = '–î–æ—Å—Ç—É–ø–Ω–æ: ' + formatTon(currentTon) + ' TON'; }
      else { withdrawStatus.className = 'withdraw-warning'; withdrawStatus.textContent = '–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ TON: ' + formatTon(currentTon); }
    }

    renderBoundInfo();
  })();

  // ========== Balances & coins helpers (ensure withdraw UI updates) ==========
  function updateBalancesDisplay(){
    if (coinsVal) coinsVal.textContent = format(coins);
    const tonEl = document.getElementById('tonVal');
    if (tonEl) tonEl.textContent = formatTon(ton);
    const wsZex = document.getElementById('wsModalCoinsDisplay');
    if (wsZex) {
      const wsTon = formatTon(ton);
      wsZex.textContent = format(coins) + ' XTR ‚Ä¢ ' + wsTon + ' TON';
    }
    const casinoBalance = document.getElementById('casinoBalance');
    if (casinoBalance) {
      casinoBalance.textContent = format(coins) + ' XTR ‚Ä¢ ' + formatTon(ton) + ' TON';
    }
  }

  function updCoins(v = 0) {
    if (typeof v !== 'number') v = Number(v) || 0;
    if (v > 0) {
      const tonGain = v * ZEX_TO_TON;
      ton += tonGain;
    }
    coins += v;
    if (coins < 0) coins = 0;
    if (coins > maxCoins) maxCoins = coins;
    updateBalancesDisplay();
    updUpg();
    updIncome();
    save();
  }

  function getIncome() {
    const base = minersState.reduce((sum, m, i) => {
      const count = (m && typeof m.count === 'number') ? m.count : 0;
      return sum + (count > 0 ? Math.floor(minersData[i].i * Math.pow(1.5, count - 1)) : 0);
    }, 0);
    if (doubleIncomeExpire > Date.now()) return base * 2;
    return base;
  }
  function updIncome() { if (miningIncomeValEl) miningIncomeValEl.textContent = format(getIncome()); }

  // ===== offline gains & income tick =====n  function addOfflineCoins() {
    const last = +localStorage.getItem(LS_LASTTIME) || Date.now();
    const now = Date.now();
    const diffMinutes = (now - last) / 60000;
    if (diffMinutes > 0) {
      const minutesToAward = Math.min(diffMinutes, 180);
      const perMin = Math.floor(getIncome()/60);
      if(perMin > 0) updCoins(perMin * minutesToAward);
    }
    localStorage.setItem(LS_LASTTIME, now);
  }
  addOfflineCoins();

  setInterval(()=>{ updCoins(Math.floor(getIncome()/3600)); }, 1000);

  // ===== upgrades UI =====
  function updUpg() {
    document.querySelectorAll('.upgrade').forEach(u => {
      let key = u.dataset.key; let base = +u.dataset.basePrice; let count = upgrades[key] || 0;
      let price = base * Math.pow(2,count);
      let priceEl = u.querySelector('.price'); if (priceEl) priceEl.textContent = format(price);
      const badge = u.querySelector('.badge'); if (badge) badge.textContent = count > 0 ? `Lvl ${count}` : 'New';
    });
  }

  document.querySelectorAll('.upgrade').forEach(u=>{
    u.onclick = ()=>{
      let key = u.dataset.key; let base = +u.dataset.basePrice; let count = upgrades[key]||0;
      let price = base * Math.pow(2,count);
      if (coins >= price) {
        upgrades[key] = count+1; updCoins(-price);
        if (key === 'check1') check1Expire = Date.now()+60000;
        if (key === 'shield') shieldExpire = Date.now()+60000;
        if (key === 'incBoost') doubleIncomeExpire = Date.now()+60000;
        if (key === 'luck') luckExpire = Date.now()+60000;
        save(); updUpg();
      } else alert(t('notEnough'));
    };
  });

  function updTimers() {
    const el = document.getElementById('check1Timer');
    if (el) {
      if (check1Expire > Date.now()) el.textContent = '‚è≥ ' + Math.floor((check1Expire - Date.now())/1000) + 's';
      else el.textContent = '';
    }
    const shEl = document.getElementById('shieldTimer');
    if (shEl) {
      if (shieldExpire > Date.now()) shEl.textContent = '‚è≥ ' + Math.floor((shieldExpire - Date.now())/1000) + 's';
      else shEl.textContent = '';
    }
    const incEl = document.getElementById('incTimer');
    if (incEl) {
      if (doubleIncomeExpire > Date.now()) incEl.textContent = '‚è≥ ' + Math.floor((doubleIncomeExpire - Date.now())/1000) + 's';
      else incEl.textContent = '';
    }
    const luckEl = document.getElementById('luckTimer');
    if (luckEl) {
      if (luckExpire > Date.now()) luckEl.textContent = '‚è≥ ' + Math.floor((luckExpire - Date.now())/1000) + 's';
      else luckEl.textContent = '';
    }
  }
  setInterval(updTimers, 1000);

  document.querySelectorAll('.room').forEach(r => {
    r.onclick = () => {
      if (roundInProgress) return;
      document.querySelectorAll('.room').forEach(x=>x.classList.remove('selected'));
      r.classList.add('selected');
      selectedRoom = +r.dataset.idx;
    };
  });

  document.getElementById('startBtn').onclick = ()=>{
    if (selectedRoom == null) { alert(t('pickRoomFirst')); return; }
    document.querySelectorAll('.room').forEach(r=>r.classList.remove('found','safe'));
  };

  document.getElementById('resetBtn').onclick = ()=>{
    if (selectedRoom == null) { alert(t('pickRoomFirst')); return; }
    if (!consumeEnergyOne()) return;
    roundInProgress = true;
    const numPicks = (check1Expire > Date.now()) ? 1 : 2;
    let picks = [...Array(8).keys()].sort(()=>0.5-Math.random()).slice(0,numPicks);
    document.querySelectorAll('.room').forEach(r=>r.classList.remove('found','safe','highlight'));
    let delay = 0;
    picks.forEach(i=>{
      let room = document.querySelector(`.room[data-idx="${i}"]`);
      setTimeout(()=>{ room.classList.add('highlight'); }, delay);
      setTimeout(()=>{ room.classList.remove('highlight'); }, delay+600);
      delay += 700;
    });
    setTimeout(()=>{
      let prize = 1000, loss = -2000;
      if (upgrades.x2Prize > 0) { prize *= Math.pow(2, upgrades.x2Prize); loss *= Math.pow(2, upgrades.x2Prize); }

      const roomEl = document.querySelector(`.room[data-idx="${selectedRoom}"]`);

      if (picks.includes(selectedRoom)) {
        if (shieldExpire > Date.now()) {
          roomEl.classList.add('safe');
          updCoins(0);
        } else if (luckExpire > Date.now() && Math.random() < 0.5) {
          roomEl.classList.add('safe');
          updCoins(prize);
        } else {
          const room = document.querySelector(`.room[data-idx="${selectedRoom}"]`);
          room.classList.add('found');
          updCoins(loss);
        }
      } else {
        const room = document.querySelector(`.room[data-idx="${selectedRoom}"]`);
        room.classList.add('safe');
        updCoins(prize);
      }
      selectedRoom = null;
      document.querySelectorAll('.room').forEach(r=>r.classList.remove('selected'));
      roundInProgress = false;
    }, delay+700);
  };

  // render miners
  function renderMiners(){
    if (!minersContainerEl) return;
    minersContainerEl.innerHTML = '';
    minersData.forEach((m,i)=>{
      const st = (minersState[i] && typeof minersState[i].count === 'number') ? minersState[i] : { count: 0 };
      const price = m.p * Math.pow(2, st.count);
      const income = st.count > 0 ? Math.floor(m.i * Math.pow(1.5, st.count - 1)) : 0;

      const card = document.createElement('div'); card.className = 'miner-card';
      card.innerHTML = `\n        <img class="card-logo" src="logo.png" alt="logo" />\n        <h3>${m.n}</h3>\n        <div class="income">+${format(income)} / hr</div>\n        <div class="bottom">\n          <span class="lvl">Lvl ${st.count}</span>\n          <span class="price-pill">${format(price)}</span>\n        </div>\n      `;
      card.onclick = ()=>{
        const currentSt = (minersState[i] && typeof minersState[i].count === 'number') ? minersState[i] : { count: 0 };
        const currentPrice = m.p * Math.pow(2, currentSt.count);
        if (coins >= currentPrice) {
          pendingMiner = i;
          if (buyText) buyText.textContent = t('buyFor', { name: m.n, price: format(currentPrice) });
          if (buyConfirm) { buyConfirm.classList.add('show'); buyConfirm.style.display = 'block'; buyConfirm.setAttribute('aria-hidden','false'); }
        } else { alert(t('notEnough')); }
      };
      minersContainerEl.appendChild(card);
    });
  }

  const miningBtn = document.getElementById('miningBtn');
  const shopBtn = document.getElementById('shopBtn'); // may be null (we removed the button)
  if (miningBtn) miningBtn.onclick = () => { if (miningShop) { miningShop.style.display = 'block'; miningShop.setAttribute('aria-hidden','false'); renderMiners(); } };
  if (shopBtn) shopBtn.onclick = () => { if (miningShop) { miningShop.style.display = 'block'; miningShop.setAttribute('aria-hidden','false'); renderMiners(); } };

  const closeMiningShopBtn = document.getElementById('closeMiningShop');
  if (closeMiningShopBtn) closeMiningShopBtn.onclick = ()=>{ if (miningShop) { miningShop.style.display = 'none'; miningShop.setAttribute('aria-hidden','true'); } };

  const closeMiningShopTop = document.getElementById('closeMiningShopTop');
  if (closeMiningShopTop) closeMiningShopTop.addEventListener('click', ()=>{ if (miningShop) { miningShop.style.display = 'none'; miningShop.setAttribute('aria-hidden','true'); } });

  document.getElementById('confirmBuy') && (document.getElementById('confirmBuy').onclick = ()=>{
    if (pendingMiner === null) return;
    const i = pendingMiner; const m = minersData[i]; const st = minersState[i] || { count: 0 };
    const price = m.p * Math.pow(2, st.count);
    if (coins >= price) {
      coins -= price; minersState[i] = { count: (st.count || 0) + 1 }; updCoins(0); save(); renderMiners();
    } else alert(t('notEnough'));
    pendingMiner = null;
    if (buyConfirm) { buyConfirm.classList.remove('show'); buyConfirm.style.display = 'none'; buyConfirm.setAttribute('aria-hidden','true'); }
  });
  document.getElementById('cancelBuy') && (document.getElementById('cancelBuy').onclick = ()=>{ pendingMiner = null; if (buyConfirm) { buyConfirm.classList.remove('show'); buyConfirm.style.display = 'none'; buyConfirm.setAttribute('aria-hidden','true'); } });

  // profile window
  const profileWindowEl = document.getElementById('profileWindow');
  const profileBtnEl = document.getElementById('profileBtn');
  if (profileBtnEl) profileBtnEl.onclick = ()=>{ if (profileWindowEl) { profileWindowEl.style.display = 'block'; profileWindowEl.setAttribute('aria-hidden','false'); } };
  const closeProfileBtn = document.getElementById('closeProfile');
  if (closeProfileBtn) closeProfileBtn.onclick = ()=>{ if (profileWindowEl) { profileWindowEl.style.display = 'none'; profileWindowEl.setAttribute('aria-hidden','true'); } };

  // daily & quest
  let questClaimed = localStorage.getItem('questClaimed') === 'true';
  let lastDaily = +localStorage.getItem('lastDaily') || 0;
  const questStatusEl = document.getElementById('questStatus');
  const dailyStatusEl = document.getElementById('dailyStatus');
  function updateQuestStatus(){ if (questStatusEl) questStatusEl.textContent = questClaimed ? "‚úÖ Completed" : "‚ùå Not claimed"; }
  function updateDailyStatus(){ if (dailyStatusEl) { const now = Date.now(); const nextAvailable = lastDaily + 24*60*60*1000; if (now >= nextAvailable) dailyStatusEl.textContent = "üí∞ Available!"; else { const diff = nextAvailable - now; const hours = Math.floor(diff / (1000*60*60)); const minutes = Math.floor((diff % (1000*60*60)) / (1000*60)); dailyStatusEl.textContent = `Next in ${hours}h ${minutes}m`; } } }
  setInterval(updateDailyStatus, 60000); updateDailyStatus(); updateQuestStatus();

  document.getElementById('claimQuest') && (document.getElementById('claimQuest').onclick = ()=>{ if (questClaimed) alert(t('questAlready')); else { updCoins(50000); questClaimed = true; localStorage.setItem('questClaimed','true'); updateQuestStatus(); } });
  document.getElementById('claimDaily') && (document.getElementById('claimDaily').onclick = ()=>{ const now = Date.now(); if (now - lastDaily < 24*60*60*1000) alert(t('dailyAlready')); else { updCoins(30000); lastDaily = now; localStorage.setItem('lastDaily', now); updateDailyStatus(); } });

  // NEW: Telegram subscribe quest logic
  let tgSubscribeClaimed = localStorage.getItem('tgSubscribeClaimed') === 'true';
  const tgStatusEl = document.getElementById('tgQuestStatus');
  function updateTgQuestStatus(){ if (tgStatusEl) tgStatusEl.textContent = tgSubscribeClaimed ? "‚úÖ Completed" : "‚ùå Not claimed"; }
  const claimTgBtn = document.getElementById('claimTgSubscribe');
  const openTgBtn = document.getElementById('openTgChannel');
  if (claimTgBtn) claimTgBtn.addEventListener('click', ()=>{
    if (tgSubscribeClaimed) { alert(t('questAlready')); return; }
    tgSubscribeClaimed = true;
    localStorage.setItem('tgSubscribeClaimed','true');
    try { updCoins(25000); } catch(e){ console.warn('updCoins missing', e); }
    updateTgQuestStatus();
  });
  if (openTgBtn) openTgBtn.addEventListener('click', ()=>{ /* anchor handles */ });
  updateTgQuestStatus();

  // info window
  const infoWindowEl = document.getElementById('infoWindow');
  const infoBtn = document.getElementById('infoBtn');
  if (infoBtn) infoBtn.onclick = ()=>{ if (infoWindowEl) { infoWindowEl.style.display = 'block'; infoWindowEl.setAttribute('aria-hidden','false'); } };
  const closeInfoBtn = document.getElementById('closeInfo');
  if (closeInfoBtn) closeInfoBtn.onclick = ()=>{ if (infoWindowEl) { infoWindowEl.style.display = 'none'; infoWindowEl.setAttribute('aria-hidden','true'); } };

  // shop toggle & UI init
  const upgradePanel = document.getElementById('upgradePanel');
  if (minersPanelVisible) minersPanelVisible.style.display = 'none';
  if (upgradePanel) upgradePanel.style.display = 'flex';

  const langSelect = document.getElementById('langSelect');
  if (langSelect) {
    langSelect.value = lang;
    langSelect.onchange = ()=>{ lang = langSelect.value; localStorage.setItem('lang', lang); applyLang(); renderMiners(); renderCards && renderCards(); };
  }

  // init
  loadEnergy();
  updateBalancesDisplay();
  updUpg();
  updIncome();
  updTimers();
  renderMiners();
  applyLang();

  document.getElementById('infoWindow') && (document.getElementById('infoWindow').style.display = 'none');
  document.getElementById('infoWindow') && (document.getElementById('infoWindow').setAttribute('aria-hidden','true'));
  document.getElementById('profileWindow') && (document.getElementById('profileWindow').style.display = 'none');
  document.getElementById('profileWindow') && (document.getElementById('profileWindow').setAttribute('aria-hidden','true'));
  if (buyConfirm) { buyConfirm.style.display = 'none'; buyConfirm.setAttribute('aria-hidden','true'); }

  /* ===========================
  Rewards modal logic (uses XTR label)
  ============================ */
  (function(){
    const LS_FIRST = 'ws_first_seen_v2';
    const LS_CLAIMED = 'ws_claimed_v2';
    const MAX_DAYS = 7;
    const amounts = [30000,100000,500000,1000000,3000000,6000000,10000000];

    function safeGetJSON(key, fallback){
      try{
        const raw = localStorage.getItem(key);
        if(!raw) return fallback;
        const v = JSON.parse(raw);
        return v;
      }catch(e){ return fallback; }
    }
    function safeSetJSON(key, obj){
      try{ localStorage.setItem(key, JSON.stringify(obj)); }catch(e){}
    }

    let firstSeen = +localStorage.getItem(LS_FIRST) || 0;
    if(!firstSeen || isNaN(firstSeen)){
      firstSeen = Date.now();
      try{ localStorage.setItem(LS_FIRST, String(firstSeen)); }catch(e){}
    }

    let claimed = safeGetJSON(LS_CLAIMED, null);
    if(!Array.isArray(claimed) || claimed.length !== MAX_DAYS){
      claimed = new Array(MAX_DAYS).fill(false);
      safeSetJSON(LS_CLAIMED, claimed);
    }

    function daysSinceFirst(){
      const now = Date.now();
      const diffDays = Math.floor((now - firstSeen) / (24*60*60*1000));
      return diffDays;
    }
    function availableCount(){
      return Math.min(MAX_DAYS, daysSinceFirst() + 1);
    }

    function formatFallback(n){
      if (n >= 1e9) return (n/1e9).toFixed(1).replace(/\.0$/,'') + 'B';
      if (n >= 1e6) return (n/1e6).toFixed(1).replace(/\.0$/,'') + 'M';
      if (n >= 1e3) return (n/1e3).toFixed(1).replace(/\.0$/,'') + 'K';
      return String(n);
    }

    function updCoinsPublic(v=0){
      try{
        let cur = +localStorage.getItem(LS_COINS) || 0;
        cur += v;
        if(cur < 0) cur = 0;
        localStorage.setItem(LS_COINS, String(cur));
        const el = document.getElementById('coinsVal');
        if(el) el.textContent = formatFallback(cur);
        let storedTon = +localStorage.getItem(LS_TON) || 0;
        if (v > 0) storedTon += v * ZEX_TO_TON;
        localStorage.setItem(LS_TON, String(storedTon));
        const tonEl = document.getElementById('tonVal');
        if (tonEl) tonEl.textContent = formatTon(storedTon);
      }catch(e){}
    }

    function saveGameStatePublic(){
      try{
        const coinsVal = localStorage.getItem(LS_COINS) || '0';
        localStorage.setItem(LS_COINS, coinsVal);
        safeSetJSON(LS_CLAIMED, claimed);
        localStorage.setItem(LS_FIRST, String(firstSeen));
      }catch(e){}
    }

    function claimRewardFromModalPublic(amount){
      try{
        if (typeof window.updCoins === 'function') {
          window.updCoins(amount);
        } else {
          let cur = +localStorage.getItem(LS_COINS) || 0;
          cur += amount;
          localStorage.setItem(LS_COINS, String(cur));
          const cv = document.getElementById('coinsVal');
          if(cv) cv.textContent = formatFallback(cur);
          let storedTon = +localStorage.getItem(LS_TON) || 0;
          storedTon += amount * ZEX_TO_TON;
          localStorage.setItem(LS_TON, String(storedTon));
          const tonEl = document.getElementById('tonVal');
          if (tonEl) tonEl.textContent = formatTon(storedTon);
        }
        saveGameStatePublic();
      }catch(e){}
    }

    window.claimRewardFromModal = window.claimRewardFromModal || claimRewardFromModalPublic;
    window.updCoins = window.updCoins || updCoinsPublic;
    window.saveGameState = window.saveGameState || saveGameStatePublic;
    window.format = window.format || formatFallback;

    const updCoins = window.updCoins;
    const claimRewardFromModal = window.claimRewardFromModal;
    const saveGameState = window.saveGameState;
    const formatNum = window.format;

    const overlay = document.getElementById('wsModalOverlay');
    const gridTop = document.getElementById('rewardsGridTop');
    const gridBottom = document.getElementById('rewardsGridBottom');
    const unlockedCountEl = document.getElementById('wsUnlockedCount');
    const coinsDisplayEl = document.getElementById('wsModalCoinsDisplay');
    const btnClose = document.getElementById('wsBtnClose');
    const btnRules = document.getElementById('wsBtnRules');

    const hiddenTargets = [];
    function hideMainUI(){
      const bodyChildren = Array.from(document.body.children);
      bodyChildren.forEach(ch=>{ if (ch === overlay) return; const prev = ch.style.display || ''; hiddenTargets.push({el: ch, prev}); ch.style.display = 'none'; });
      overlay.classList.remove('hidden');
    }
    function showMainUI(){
      hiddenTargets.forEach(item=>{ try{ item.el.style.display = item.prev || ''; }catch(e){} });
      hiddenTargets.length = 0;
      overlay.classList.add('hidden');
    }

    function renderCards(){
      claimed = safeGetJSON(LS_CLAIMED, claimed) || claimed;

      const avail = availableCount();
      gridTop.innerHTML = '';
      gridBottom.innerHTML = '';

      for(let i=0;i<MAX_DAYS;i++){
        const day = i+1;
        const amount = amounts[i] || 0;
        const card = document.createElement('div');
        card.className = 'rewardCard';
        if (day === 7) card.classList.add('big');

        card.innerHTML = `
          <div class="coinIconSmall">üí∞</div>
          <div class="dayLabel">${t('dayLabel') || 'Day'} ${day}</div>
          <div class="amount">${formatNum(amount)}</div>
        `;

        const isUnlocked = i < avail;
        const isClaimed = !!claimed[i];

        if(isClaimed){
          card.classList.add('claimed');
          const badge = document.createElement('div');
          badge.className = 'claimBadge';
          badge.textContent = t('claimed') || 'Claimed';
          card.appendChild(badge);
        } else if(isUnlocked){
          card.classList.add('unlocked');
        } else {
          card.classList.add('locked');
        }

        card.addEventListener('click', function onCardClick(){
          claimed = safeGetJSON(LS_CLAIMED, claimed) || claimed;
          const nowClaimed = !!claimed[i];
          const nowAvail = i < availableCount();
          if (!nowAvail || nowClaimed) return;

          card.style.pointerEvents = 'none';
          card.classList.add('pop');
          setTimeout(()=>card.classList.remove('pop'),260);

          claimed[i] = true;
          safeSetJSON(LS_CLAIMED, claimed);

          try {
            if (typeof claimRewardFromModal === 'function') {
              claimRewardFromModal(amounts[i]);
            } else if (typeof updCoins === 'function') {
              updCoins(amounts[i]);
            } else {
              let cur = +localStorage.getItem(LS_COINS) || 0;
              cur += amounts[i];
              localStorage.setItem(LS_COINS, String(cur));
              const mainEl = document.getElementById('coinsVal');
              if (mainEl) mainEl.textContent = formatNum(cur);
            }
            saveGameStatePublic();
          } catch(e){
            console.error('claimReward error', e);
            try { updCoinsPublic(amounts[i]); } catch(e2){}
          }

          const badge = document.createElement('div');
          badge.className = 'claimBadge';
          badge.textContent = t('claimed') || 'Claimed';
          card.appendChild(badge);
          card.classList.remove('unlocked');
          card.classList.add('claimed');
          card.style.pointerEvents = 'none';

          syncCoinsDisplay();
          renderUnlockedCount();
        });

        if(i < 4) gridTop.appendChild(card);
        else gridBottom.appendChild(card);
      }

      renderUnlockedCount();
    }

    function renderUnlockedCount(){
      const avail = availableCount();
      const unlockedNow = Math.min(avail, MAX_DAYS);
      unlockedCountEl.textContent = String(unlockedNow);
    }

    function syncCoinsDisplay(){
      const coinsLocal = +localStorage.getItem(LS_COINS) || 0;
      const tonLocal = +localStorage.getItem(LS_TON) || 0;
      coinsDisplayEl.textContent = formatNum(coinsLocal) + ' XTR ‚Ä¢ ' + formatTon(tonLocal) + ' TON';
      const mainEl = document.getElementById('coinsVal');
      if (mainEl) mainEl.textContent = formatNum(coinsLocal);
      const tonEl = document.getElementById('tonVal');
      if (tonEl) tonEl.textContent = formatTon(tonLocal);
    }

    if (btnClose) btnClose.addEventListener('click', function(){
      showMainUI();
      saveGameState();
    });

    if (btnRules) btnRules.addEventListener('click', function(){
      alert(t('wsBtnRules') ? t('wsBtnRules') + ': ' + (t('wsSub') || '') : 'Rewards unlock one per day since first visit. Click an unlocked card to claim its coins.');
    });

    hideMainUI();
    renderCards();
    syncCoinsDisplay();

    setInterval(()=>{ renderCards(); syncCoinsDisplay(); }, 60*1000);

    window._wsModal = {
      open: function(){ hideMainUI(); renderCards(); syncCoinsDisplay(); },
      close: function(){ showMainUI(); saveGameState(); },
      getState: function(){ return { firstSeen, claimed: claimed.slice(), available: availableCount() }; },
      forceResetClaims: function(){ claimed = new Array(MAX_DAYS).fill(false); safeSetJSON(LS_CLAIMED,claimed); renderCards(); }
    };

    overlay.tabIndex = -1;
  })();

  /* ===========================
  Casino modal & logic (XTR labels)
  ============================ */
  (function(){
    const casinoBtn = document.getElementById('casinoBtn');
    const casinoModal = document.getElementById('casinoModal');
    const closeCasino = document.getElementById('closeCasino');
    const spinBtn = document.getElementById('spinBtn');
    const casinoCooldownEl = document.getElementById('casinoCooldown');
    const casinoResultEl = document.getElementById('casinoResult');
    const casinoBalanceEl = document.getElementById('casinoBalance');
    const wheelCanvas = document.getElementById('wheelCanvas');
    const ctx = wheelCanvas && wheelCanvas.getContext ? wheelCanvas.getContext('2d') : null;

    const segments = [
      { label: '100K XTR', type: 'zex', value: 100000 },
      { label: '0.10 TON', type: 'ton', value: 0.10 },
      { label: '5K XTR', type: 'zex', value: 5000 },
      { label: '0.50 TON', type: 'ton', value: 0.50 },
      { label: '10K XTR', type: 'zex', value: 10000 },
      { label: '1 TON', type: 'ton', value: 1 },
      { label: '50K XTR', type: 'zex', value: 50000 },
      { label: '0.20 TON', type: 'ton', value: 0.20 },
      { label: '1K XTR', type: 'zex', value: 1000 },
      { label: '2 TON', type: 'ton', value: 2 }
    ];

    const SEG_COUNT = segments.length;
    const COOL_KEY = 'casino_last_spin_v2';
    const COOLDOWN_MS = 2 * 60 * 60 * 1000;

    let rotation = 0;
    let isSpinning = false;

    function drawWheel(){
      if(!ctx) return;
      const w = wheelCanvas.width;
      const h = wheelCanvas.height;
      const cx = w/2;
      const cy = h/2;
      const radius = Math.min(cx,cy) - 8;
      ctx.clearRect(0,0,w,h);
      const anglePer = 2*Math.PI / SEG_COUNT;
      for(let i=0;i<SEG_COUNT;i++){
        const start = i*anglePer - Math.PI/2;
        const end = start + anglePer;
        ctx.beginPath();
        ctx.moveTo(cx,cy);
        ctx.arc(cx,cy,radius,start,end);
        ctx.closePath();
        ctx.fillStyle = (i%2===0) ? 'rgba(255,255,255,0.04)' : 'rgba(255,255,255,0.02)';
        ctx.fill();
        ctx.strokeStyle = 'rgba(255,255,255,0.06)';
        ctx.lineWidth = 2;
        ctx.stroke();

        ctx.save();
        const textAngle = start + anglePer/2;
        ctx.translate(cx + Math.cos(textAngle)*(radius*0.66), cy + Math.sin(textAngle)*(radius*0.66));
        ctx.rotate(textAngle + Math.PI/2);
        ctx.fillStyle = '#ecf8ff';
        ctx.font = 'bold 22px Inter, system-ui, Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(segments[i].label, 0, 0);
        ctx.restore();
      }

      ctx.beginPath();
      ctx.arc(cx,cy,60,0,2*Math.PI);
      ctx.fillStyle = 'rgba(0,0,0,0.18)';
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,0.04)';
      ctx.stroke();
    }

    function render(){ if(wheelCanvas) wheelCanvas.style.transform = `rotate(${rotation}deg)`; }

    function getRandomSegmentIndex(){ return Math.floor(Math.random()*SEG_COUNT); }

    function angleForIndex(i){
      const anglePerDeg = 360 / SEG_COUNT;
      const center = i * anglePerDeg + anglePerDeg/2;
      return (360 - center) % 360;
    }

    function spinToIndex(i){
      if (isSpinning) return;
      isSpinning = true;
      spinBtn.disabled = true;
      const baseSpins = 6;
      const targetAngle = angleForIndex(i);
      const randomOffset = (Math.random()*15) - 7.5;
      const finalAngle = baseSpins*360 + targetAngle + randomOffset;
      const duration = 5000 + Math.random()*1000;
      const start = performance.now();
      const from = rotation % 360;
      const to = rotation + finalAngle;
      function easeOutCubic(t){ return 1 - Math.pow(1-t,3); }
      function step(now){
        const elapsed = now - start;
        const p = Math.min(1, elapsed / duration);
        const eased = easeOutCubic(p);
        rotation = from + (to - from) * eased;
        render();
        if(p < 1) requestAnimationFrame(step);
        else {
          isSpinning = false;
          spinBtn.disabled = false;
          const landed = ((360 - (rotation % 360)) + 360) % 360;
          const anglePerDeg = 360 / SEG_COUNT;
          let idx = Math.floor((landed) / anglePerDeg);
          idx = (idx + SEG_COUNT) % SEG_COUNT;
          announcePrize(idx);
        }
      }
      requestAnimationFrame(step);
    }

    function announcePrize(idx){
      const seg = segments[idx];
      if(!seg) return;
      let text = '';
      if(seg.type === 'zex'){
        const amount = Math.round(seg.value);
        try{
          if(typeof window.updCoins === 'function') window.updCoins(amount);
          else {
            let cur = +localStorage.getItem(LS_COINS) || 0;
            cur += amount;
            localStorage.setItem(LS_COINS, String(cur));
            let storedTon = +localStorage.getItem(LS_TON) || 0;
            storedTon += amount * ZEX_TO_TON;
            localStorage.setItem(LS_TON, String(storedTon));
          }
        }catch(e){
          let cur = +localStorage.getItem(LS_COINS) || 0;
          cur += amount;
          localStorage.setItem(LS_COINS, String(cur));
          let storedTon = +localStorage.getItem(LS_TON) || 0;
          storedTon += amount * ZEX_TO_TON;
          localStorage.setItem(LS_TON, String(storedTon));
        }
        text = `+${format(amount)} XTR`;
      } else {
        const tonAmount = seg.value;
        try{
          ton += tonAmount;
          localStorage.setItem(LS_TON, String(ton));
        }catch(e){
          let storedTon = +localStorage.getItem(LS_TON) || 0;
          storedTon += tonAmount;
          localStorage.setItem(LS_TON, String(storedTon));
        }
        text = `+${tonAmount.toFixed(2)} TON`;
      }
      casinoResultEl.textContent = text;
      updateCasinoBalanceDisplay();
      localStorage.setItem(COOL_KEY, String(Date.now()));
      updateCooldownDisplay();
      localStorage.setItem(LS_COINS, String(coins));
      localStorage.setItem(LS_TON, String(ton));
    }

    function updateCasinoBalanceDisplay(){
      const c = +localStorage.getItem(LS_COINS) || coins || 0;
      const tLocal = +localStorage.getItem(LS_TON) || ton || 0;
      if (casinoBalanceEl) casinoBalanceEl.textContent = format(c) + ' XTR ‚Ä¢ ' + formatTon(tLocal) + ' TON';
      const mainEl = document.getElementById('coinsVal');
      if(mainEl) mainEl.textContent = format(c);
      const tonEl = document.getElementById('tonVal');
      if(tonEl) tonEl.textContent = formatTon(tLocal);
    }

    function updateCooldownDisplay(){
      const last = +localStorage.getItem(COOL_KEY) || 0;
      const now = Date.now();
      const diff = now - last;
      if(last === 0 || diff >= COOLDOWN_MS){
        casinoCooldownEl.textContent = t('ready') || 'Ready';
        spinBtn.disabled = false;
      } else {
        const rem = COOLDOWN_MS - diff;
        const hours = Math.floor(rem / (1000*60*60));
        const minutes = Math.floor((rem % (1000*60*60)) / (1000*60));
        const seconds = Math.floor((rem % (1000*60)) / 1000);
        casinoCooldownEl.textContent = `${hours}h ${minutes}m ${seconds}s`;
        spinBtn.disabled = true;
      }
    }

    if (casinoBtn) casinoBtn.addEventListener('click', ()=>{
      if (casinoModal) { casinoModal.style.display = 'flex'; casinoModal.setAttribute('aria-hidden','false'); updateCasinoBalanceDisplay(); updateCooldownDisplay(); }
    });
    if (closeCasino) closeCasino.addEventListener('click', ()=>{ if (casinoModal) { casinoModal.style.display = 'none'; casinoModal.setAttribute('aria-hidden','true'); } });

    if (spinBtn) spinBtn.addEventListener('click', ()=>{
      const last = +localStorage.getItem(COOL_KEY) || 0;
      const now = Date.now();
      if(last && now - last < COOLDOWN_MS){
        updateCooldownDisplay();
        return;
      }
      const idx = getRandomSegmentIndex();
      spinToIndex(idx);
    });

    drawWheel();
    render();
    setInterval(updateCooldownDisplay, 1000);

    function format(n){
      if(typeof window.format === 'function') return window.format(n);
      if(n >= 1e9) return (n/1e9).toFixed(1).replace(/\.0$/,'') + 'B';
      if(n >= 1e6) return (n/1e6).toFixed(1).replace(/\.0$/,'') + 'M';
      if(n >= 1e3) return (n/1e3).toFixed(1).replace(/\.0$/,'') + 'K';
      return String(n);
    }

    window._casino = {
      open: ()=>{ if (casinoModal) { casinoModal.style.display = 'flex'; casinoModal.setAttribute('aria-hidden','false'); updateCasinoBalanceDisplay(); updateCooldownDisplay(); } },
      close: ()=>{ if (casinoModal) { casinoModal.style.display = 'none'; casinoModal.setAttribute('aria-hidden','true'); } },
      lastSpin: ()=>+localStorage.getItem(COOL_KEY) || 0
    };
  })();
</script>
</body>
</html>
