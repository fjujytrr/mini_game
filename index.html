<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Game</title>
  <style>
    /* Assuming existing styles are here; adding/changing for miners shop */
    .miners-container {
      background-image: url('fonn.png');
      background-size: cover;
      background-position: center;
      /* Add any other styling for the container if needed */
    }
    .miner-card {
      width: 160px; /* Increased width (assuming previous was smaller, e.g., 140px) */
      /* Other card styles */
    }
    /* Hide info button and window in bottom menu (assuming IDs or classes) */
    #infoBtn {
      display: none !important;
    }
    #infoWindow {
      display: none !important;
    }
    /* Rest of your CSS */
  </style>
</head>
<body>
  <!-- Assuming full HTML structure here; changes embedded in script/style -->

  <script>
    // All the provided JS code remains the same, except integrations with new styles
    // ========== UI & State ==========
    const roomsContainer = document.querySelector('.house');
    for (let i = 0; i < 8; i++) {
      const d = document.createElement('div');
      d.className = 'room';
      d.dataset.idx = i;
      d.textContent = '+';
      roomsContainer.appendChild(d);
    }
    let selectedRoom = null;

    // coins (XTR) and ton are separate now
    let coins = +localStorage.getItem(LS_COINS) || 0;
    let maxCoins = +localStorage.getItem(LS_MAXCOINS) || coins;
    let ton = +localStorage.getItem(LS_TON) || 0; // TON stored independently

    const coinsVal = document.getElementById('coinsVal');
    let upgrades = JSON.parse(localStorage.getItem(LS_UPGRADES)) || { x2Prize: 0, check1: 0 };
    let check1Expire = +localStorage.getItem('check1Expire') || 0;
    let roundInProgress = false;

    let shieldExpire = +localStorage.getItem('shieldExpire') || 0;
    let doubleIncomeExpire = +localStorage.getItem('doubleIncomeExpire') || 0;
    let luckExpire = +localStorage.getItem('luckExpire') || 0;

    const minersData = [
      { n: "Miner 1", i: 500, p: 7000 },
      { n: "Miner 2", i: 1788, p: 12000 },
      { n: "Miner 3", i: 2358, p: 15000 },
      { n: "Miner 4", i: 3000, p: 20000 },
      { n: "Miner 5", i: 4500, p: 25000 },
      { n: "Miner 6", i: 5200, p: 30000 },
      { n: "Miner 7", i: 6100, p: 35000 },
      { n: "Miner 8", i: 7200, p: 40000 },
      { n: "Miner 9", i: 8500, p: 45000 },
      { n: "Miner 10", i: 9500, p: 50000 }
    ];

    let minersState;
    try {
      const saved = JSON.parse(localStorage.getItem(LS_MINERS));
      if (Array.isArray(saved)) {
        minersState = minersData.map((_, i) => {
          const s = saved[i];
          if (s && typeof s.count === 'number') return { count: s.count };
          return { countable: 0 };
        });
      } else {
        minersState = minersData.map(_ => ({ count: 0 }));
      }
    } catch (e) {
      minersState = minersData.map(_ => ({ count: 0 }));
    }

    const miningIncomeValEl = document.getElementById('miningIncomeVal');
    const minersContainerEl = document.querySelector('.miners-container');
    const minersPanelVisible = document.getElementById('minersPanelVisible');
    const miningShop = document.getElementById('miningShop');
    const buyConfirm = document.getElementById('buyConfirm');
    const buyText = document.getElementById('buyText');
    let pendingMiner = null;

    function format(n) {
      return n >= 1e9 ? (n/1e9).toFixed(1).replace(/\.0$/,'') + 'B' :
             n >= 1e6 ? (n/1e6).toFixed(1).replace(/\.0$/,'') + 'M' :
             n >= 1e3 ? (n/1e3).toFixed(1).replace(/\.0$/,'') + 'K' : String(n);
    }

    // TON formatting: always 2 decimals
    function formatTon(n){
      if (!isFinite(n)) return '0.00';
      return Number(n).toFixed(2);
    }
    // expose globally so other modules inside page can use
    window.formatTon = formatTon;

    function save() {
      try {
        localStorage.setItem(LS_COINS, String(coins));
        localStorage.setItem(LS_MAXCOINS, String(maxCoins));
        localStorage.setItem(LS_UPGRADES, JSON.stringify(upgrades));
        localStorage.setItem('check1Expire', check1Expire);
        localStorage.setItem(LS_MINERS, JSON.stringify(minersState));
        localStorage.setItem(LS_LASTTIME, Date.now());
        localStorage.setItem('lang', lang);
        localStorage.setItem('shieldExpire', shieldExpire);
        localStorage.setItem('doubleIncomeExpire', doubleIncomeExpire);
        localStorage.setItem('luckExpire', luckExpire);
        localStorage.setItem(LS_TON, String(ton));
      } catch (e) {
        console.warn('Save failed', e);
      }
    }

   // ========== Withdraw UI implementation (simplified) ==========
    (function(){
      const withdrawBtn = document.getElementById('withdrawBtn');
      const withdrawModal = document.getElementById('withdrawModal');
      const withdrawInput = document.getElementById('withdrawAddressInput');
      const saveAddrBtn = document.getElementById('saveWithdrawAddr');
      const changeAddrBtn = document.getElementById('changeWithdrawAddr');
      const copyAddrBtn = document.getElementById('copyAddrBtn');
      const boundInfo = document.getElementById('boundAddrInfo');
      const withdrawStatus = document.getElementById('withdrawStatus');
      const closeWithdraw = document.getElementById('closeWithdraw');

      function loadBoundAddr(){ return localStorage.getItem(LS_WITHDRAW_ADDR) || ''; }
      function saveBoundAddr(addr){ try{ localStorage.setItem(LS_WITHDRAW_ADDR, addr); }catch(e){} }
      function maskAddr(a){ if(!a) return ''; if(a.length <= 10) return a; return a.slice(0,6) + '...' + a.slice(-6); }

      function renderBoundInfo(){
        const a = loadBoundAddr();
        if(a){
          boundInfo.textContent = 'Привязанный адрес: ' + maskAddr(a);
          if(withdrawInput) withdrawInput.style.display = 'none';
          if(saveAddrBtn) saveAddrBtn.style.display = 'none';
          if(changeAddrBtn) changeAddrBtn.style.display = 'inline-block';
          if(copyAddrBtn) copyAddrBtn.style.display = 'inline-block';
        } else {
          boundInfo.textContent = 'Адрес не привязан.';
          if(withdrawInput) withdrawInput.style.display = 'block';
          if(saveAddrBtn) saveAddrBtn.style.display = 'inline-block';
          if(changeAddrBtn) changeAddrBtn.style.display = 'none';
          if(copyAddrBtn) copyAddrBtn.style.display = 'none';
        }
      }

      function openWithdraw(){
        if (!withdrawModal) return;
        withdrawModal.style.display = 'flex';
        withdrawModal.setAttribute('aria-hidden','false');
        renderBoundInfo();
        updateWithdrawStatus();
      }

      function closeWithdrawModal(){
        if (!withdrawModal) return;
        withdrawModal.style.display = 'none';
        withdrawModal.setAttribute('aria-hidden','true');
      }

      if (withdrawBtn) withdrawBtn.addEventListener('click', openWithdraw);
      if (closeWithdraw) closeWithdraw.addEventListener('click', closeWithdrawModal);

      if (saveAddrBtn) saveAddrBtn.addEventListener('click', ()=>{
        const v = (withdrawInput.value || '').trim();
        if(!v){ alert('Введите адрес'); return; }
        saveBoundAddr(v);
        renderBoundInfo();
        if(withdrawStatus) withdrawStatus.textContent = 'Адрес сохранён.';
        save();
      });

      if (changeAddrBtn) changeAddrBtn.addEventListener('click', ()=>{ 
        if(withdrawInput) withdrawInput.style.display = 'block';
        if(withdrawInput) withdrawInput.value = '';
        if(saveAddrBtn) saveAddrBtn.style.display = 'inline-block';
        if(changeAddrBtn) changeAddrBtn.style.display = 'none';
        if(copyAddrBtn) copyAddrBtn.style.display = 'none';
        if(boundInfo) boundInfo.textContent = 'Введите новый адрес.';
      });

      if (copyAddrBtn) copyAddrBtn.addEventListener('click', ()=>{
        const a = loadBoundAddr();
        if(!a) return;
        navigator.clipboard && navigator.clipboard.writeText(a).then(()=>{ if(withdrawStatus) withdrawStatus.textContent = 'Адрес скопирован.'; }).catch(()=>{ if(withdrawStatus) withdrawStatus.textContent = 'Не удалось скопировать.'; });
      });

      function updateWithdrawStatus(){
        const currentTon = +localStorage.getItem(LS_TON) || ton || 0;
        if(!withdrawStatus) return;
        if(currentTon >= 7){ withdrawStatus.className = 'withdraw-success'; withdrawStatus.textContent = 'Доступно: ' + formatTon(currentTon) + ' TON'; }
        else { withdrawStatus.className = 'withdraw-warning'; withdrawStatus.textContent = 'Недостаточно TON: ' + formatTon(currentTon); }
      }

      renderBoundInfo();
    })();

    // ========== Balances & coins helpers (ensure withdraw UI updates) ==========
    function updateBalancesDisplay(){
      // show coins normally
      if (coinsVal) coinsVal.textContent = format(coins);
      // TON now from independent 'ton' variable (doesn't decrease when spending coins)
      const tonEl = document.getElementById('tonVal');
      if (tonEl) tonEl.textContent = formatTon(ton);
      const wsZex = document.getElementById('wsModalCoinsDisplay');
      if (wsZex) {
        const wsTon = formatTon(ton);
        wsZex.textContent = format(coins) + ' XTR • ' + wsTon + ' TON';
      }
      const casinoBalance = document.getElementById('casinoBalance');
      if (casinoBalance) {
        casinoBalance.textContent = format(coins) + ' XTR • ' + formatTon(ton) + ' TON';
      }
    }

    // When updCoins is called with positive v, we increase coins and also increase TON proportionally.
    // When v is negative (spending), coins decrease but TON stays the same.
    function updCoins(v = 0) {
      if (typeof v !== 'number') v = Number(v) || 0;
      if (v > 0) {
        // earn coins -> also convert earned XTR to TON (TON only rises on gains)
        const tonGain = v * ZEX_TO_TON;
        ton += tonGain;
      }
      coins += v;
      if (coins < 0) coins = 0;
      if (coins > maxCoins) maxCoins = coins;
      updateBalancesDisplay();
      updUpg();
      updIncome();
      save();
    }

    function getIncome() {
      const base = minersState.reduce((sum, m, i) => {
        const count = (m && typeof m.count === 'number') ? m.count : 0;
        return sum + (count > 0 ? Math.floor(minersData[i].i * Math.pow(1.5, count - 1)) : 0);
      }, 0);
      if (doubleIncomeExpire > Date.now()) return base * 2;
      return base;
    }
    function updIncome() { if (miningIncomeValEl) miningIncomeValEl.textContent = format(getIncome()); }

    // ===== offline gains & income tick =====
    function addOfflineCoins() {
      const last = +localStorage.getItem(LS_LASTTIME) || Date.now();
      const now = Date.now();
      const diffMinutes = (now - last) / 60000;
      if (diffMinutes > 0) {
        const minutesToAward = Math.min(diffMinutes, 180);
        const perMin = Math.floor(getIncome()/60);
        if(perMin > 0) updCoins(perMin * minutesToAward);
      }
      localStorage.setItem(LS_LASTTIME, now);
    }
    addOfflineInit();
    addOfflineCoins();

    // income per second (approx)
    setInterval(()=>{ updCoins(Math.floor(getIncome()/3600)); }, 1000);

    // ===== upgrades UI =====
    function updUpg() {
      document.querySelectorAll('.upgrade').forEach(u => {
        let key = u.dataset.key; let base = +u.dataset.basePrice; let count = upgrades[key] || 0;
        let price = base * Math.pow(2,count);
        let priceEl = u.querySelector('.price'); if (priceEl) priceEl.text concert = format(price);
        const badge = u.querySelector('.badge'); if (badge) badge.textContent = count > 0 ? `Lvl ${count}` : 'New';
      });
    }

    document.querySelectorAll('.upgrade').forEach(u=>{
      u.onclick = ()=>{
        let key = u.dataset.key; let base = +u.dataset.basePrice; let count = upgrades[key]||0;
        let price = base * Math.pow(2,count);
        if (coins >= price) {
          upgrades[key] = count+1; updCoins(-price);
          if (key === 'check1') check1Expire = Date.now()+60000;
          if (key === 'shield') shieldExpire = Date.now()+60000;
          if (key === 'incBoost') doubleIncomeExpire = Date.now()+60000;
          if (key === 'luck') luckExpire = Date.now()+60000;
          save(); updUpg();
        } else alert(t('notEnough'));
      };
    });

    function updTimers() {
      const el = document.getElementById('check1Timer');
      if (el) {
        if (check1Expire > Date.now()) el.textContent = '⏳ ' + Math.floor((check1Expire - Date.now())/1000) + 's';
        else el.textContent = '';
      }
      const shEl = document.getElementById('shieldTimer');
      if (shEl) {
        if (shieldExpire > Date.now()) shEl.textContent = '⏳ ' + Math.floor((shieldExpire - Date.now())/1000) + 's';
        else shEl.textContent = '';
      }
      const incEl = document.getElementById('incTimer');
      if (incEl) {
        if (doubleIncomeExpire > Date.now()) incEl.textContent = '⏳ ' + Math.floor((doubleIncomeExpire - Date.now())/1000) + 's';
        else incEl.textContent = '';
      }
      const luckEl = document.getElementById('luckTimer');
      if (luckEl) {
        if (luckExpire > Date.now()) luckEl.textContent = '⏳ ' + Math.floor((luckExpire - Date.now())/1000) + 's';
        else luckEl.textContent = '';
      }
    }
    setInterval(updTimers, 1000);

    document.querySelectorAll('.room').forEach(r => {
      r.onclick = () => {
        if (roundInProgress) return;
        document.querySelectorAll('.room').forEach(x=>x.classList.remove('selected'));
        r.classList.add('selected');
        selectedRoom = +r.dataset.idx;
      };
    });

    document.getElementById('startBtn').onclick = ()=>{
      if (selectedRoom == null) { alert(t('pickRoomFirst')); return; }
      document.querySelectorAll('.room').forEach(r=>r.classList.remove('found','safe'));
    };

    document.getElementById('resetBtn').onclick = ()=>{
      if (selectedRoom == null) { alert(t('pickRoomFirst')); return; }
      if (!consumeEnergyOne()) return;
      roundInProgress = true;
      const numPicks = (check1Expire > Date.now()) ? 1 : 2;
      let picks = [...Array(8).keys()].sort(()=>0.5-Math.random()).slice(0,numPicks);
      document.querySelectorAll('.room').forEach(r=>r.classList.remove('found','safe','highlight'));
      let delay = 0;
      picks.forEach(i=>{
        let room = document.querySelector(`.room[data-idx="${i}"]`);
        setTimeout(()=>{ room.classList.add('highlight'); }, delay);
        setTimeout(()=>{ room.classList.remove('highlight'); }, delay+600);
        delay += 700;
      });
      setTimeout(()=>{
        let prize = 1000, loss = -2000;
        if (upgrades.x2Prize > 0) { prize *= Math.pow(2, upgrades.x2Prize); loss *= Math.pow(2, upgrades.x2Prize); }

        const roomEl = document.querySelector(`.room[data-idx="${selectedRoom}"]`);

        if (picks.includes(selectedRoom)) {
          if (shieldExpire > Date.now()) {
            roomEl.classList.add('safe');
            updCoins(0);
          } else if (luckExpire > Date.now() && Math.random() < 0.5) {
            roomEl.classList.add('safe');
            updCoins(prize);
          } else {
            const room = document.querySelector(`.room[data-idx="${selectedRoom}"]`);
            room.classList.add('found');
            updCoins(loss);
          }
        } else {
          const room = document.querySelector(`.room[data-idx="${selectedRoom}"]`);
          room.classList.add('safe');
          updCoins(prize);
        }
        selectedRoom = null;
        document.querySelectorAll('.room').forEach(r=>r.classList.remove('selected'));
        roundInProgress = false;
      }, delay+700);
    };

    // render miners
    function renderMiners(){
      if (!minersContainerEl) return;
      minersContainerEl.innerHTML = '';
      minersData.forEach((m,i)=>{
        const st = (minersState[i] && typeof minersState[i].count === 'number') ? minersState[i] : { count: 0 };
        const847 price = m.p * Math.pow(2, st.count);
        const income = st.count > 0 ? Math.floor(m.i * Math.pow(1.5, st.count - 1)) : 0;

        const card = document.createElement('div'); card.className = 'miner-card';
        card.innerHTML = `
          <img class="card-logo" src="logo.png" alt="logo" />
          <h3>${m.n}</h3>
          <div class="income">+${format(income)} / hr</div>
          <div class="bottom">
            <span class="lvl">Lvl ${st.count}</span>
            <span class="price-pill">${format(price)}</span>
          </div>
        `;
        card.onclick = ()=>{
          const currentSt = (minersState[i] && typeof minersState[i].count === 'number') ? minersState[i] : { count: 0 };
          const currentPrice = m.p * Math.pow(2, currentSt.count);
          if (coins >= currentPrice) {
            pendingMiner = i;
            buyText.textContent = t('buyFor', { name: m.n, price: format(currentPrice) });
            buyConfirm.classList.add('show'); buyConfirm.style.display = 'block'; buyConfirm.setAttribute('aria-hidden','false');
          } else { alert(t('notEnough')); }
        };
        minersContainerEl.appendChild(card);
      });
    }

    const miningBtn = document.getElementById('miningBtn');
    const shopBtn = document.getElementById('shopBtn'); // may be null (we removed the button)
    if (miningBtn) miningBtn.onclick = () => { if (miningShop) { miningShop.style.display = 'block'; miningShop.setAttribute('aria-hidden','false'); renderMiners(); } };
    if (shopBtn) shopBtn.onclick = () => { if (miningShop) { miningShop.style.display = 'block'; miningShop.setAttribute('aria-hidden','false'); renderMiners(); } };
    const closeMiningShopBtn = document.getElementById('closeMiningShop');
    if (closeMiningShopBtn) closeMiningShopBtn.onclick = ()=>{ if (miningShop) { miningShop.style.display = 'none'; miningShop.setAttribute('aria-hidden','true'); } };

    // Added: top-right close button for mining shop
    const closeMiningShopTop = document.getElementById('closeMiningShopTop');
    if (closeMiningShopTop) closeMiningShopTop.addEventListener('click', ()=>{ if (miningShop) { miningShop.style.display = 'none'; miningShop.setAttribute('aria-hidden','true'); } });

    document.getElementById('confirmBuy') && (document.getElementById('confirmBuy').onclick = ()=>{
      if (pendingMiner === null) return;
      const i = pendingMiner; const m = minersData[i]; const st = minersState[i] || { count: 0 };
      const price = m.p * Math.pow(2, st.count);
      if (coins >= price) {
        coins -= price; minersState[i] = { count: (st.count || 0) + 1 }; updCoins(0); save(); renderMiners();
      } else alert(t('notEnough'));
      pendingMiner = null;
      buyConfirm.classList.remove('show'); buyConfirm.style.display = 'none'; buyConfirm.setAttribute('aria-hidden','true');
    });
    document.getElementById('cancelBuy') && (document.getElementById('cancelBuy').onclick = ()=>{ pendingMiner = null; buyConfirm.classList.remove('show'); buyConfirm.style.display = 'none'; buyConfirm.setAttribute('aria-hidden','true'); });

    // profile window
    const profileWindowEl = document.getElementById('profileWindow');
    const profileBtnEl = document.getElementById('profileBtn');
    if (profileBtnEl) profileBtnEl.onclick = ()=>{ if (profileWindowEl) { profileWindowEl.style.display = 'block'; profileWindowEl.setAttribute('aria-hidden','false'); } };
    const closeProfileBtn = document.getElementById('closeProfile');
    if (closeProfileBtn) closeProfileBtn.onclick = ()=>{ if (profileWindowEl) { profileWindowEl.style.display = 'none'; profileWindowEl.setAttribute('aria-hidden','true'); } };

    // daily & quest
    let questClaimed = localStorage.getItem('questClaimed') === 'true';
    let lastDaily = +localStorage.getItem('lastDaily') || 0;
    const questStatusEl = document.getElementById('questStatus');
    const dailyStatusEl = document.getElementById('dailyStatus');
    function updateQuestStatus(){ if (questStatusEl) questStatusEl.textContent = questClaimed ? "Completed" : "Not claimed"; }
    function updateDailyStatus(){ if (dailyStatusEl) { const now = Date.now(); const nextAvailable = lastDaily + 24*60* 'Next in ${hours}h ${minutes}m`; } } }
    setInterval(updateDailyStatus, 60000); updateDailyStatus(); updateQuestStatus();

    document.getElementById('claimQuest') && (document.getElementById('claimQuest').onclick = ()=>{ if (questClaimed) alert(t('questAlready')); else { updCoins(50000); questClaimed = true; localStorage.setItem('questClaimed','true'); updateQuestStatus(); } });
    document.getElementById('claimDaily') && (document.getElementById('claimDaily').onclick = ()=>{ const now = Date.now(); if (now - lastDaily < 24*60*60*1000) alert(t('dailyAlready')); else { updCoins(30000); lastDaily = now; localStorage.setItem('lastDaily', now); updateDailyStatus(); } });

    // NEW: Telegram subscribe quest logic
    let tgSubscribeClaimed = localStorage.getItem('tgSubscribeClaimed') === 'true';
    const tgStatusEl = document.getElementById('tgQuestStatus');
    function updateTgQuestStatus(){ if (tgStatusEl) tgStatusEl.textContent = tgSubscribeClaimed ? "Completed" : "Not claimed"; }
    const claimTgBtn = document.getElementById('claimTgSubscribe');
    const openTgBtn = document.getElementById('openTgChannel');
    if (claimTgBtn) claimTgBtn.addEventListener('click', ()=>{
      if (tgSubscribeClaimed) { alert(t('questAlready')); return; }
      tgSubscribeClaimed = true;
      localStorage.setItem('tgSubscribeClaimed','true');
      try { updCoins(25000); } catch(e){ console.warn('updCoins missing', e); }
      updateTgQuestStatus();
    });
    if (openTgBtn) openTgBtn.addEventListener('click', ()=>{ /* anchor handles */ });
    updateTgQuestStatus();

    // info window - removed handlers to disable
    // No longer attaching events or showing

    // shop toggle & UI init
    const upgradePanel = document.getElementById('upgradePanel');
    if (minersPanelVisible) minersPanelVisible.style.display = 'none';
    if (upgradePanel) upgradePanel.style.display = 'flex';

    const langSelect = document.getElementById('langSelect');
    if (langSelect) {
      langSelect.value = lang;
      langSelect.onchange = ()=>{ lang = langSelect.value; localStorage.setItem('lang', lang); applyLang(); renderMiners(); renderCards && renderCards(); };
    }

    // init
    loadEnergy();
    updateBalancesDisplay();
    updUpg();
    updIncome();
    updTimers();
    renderMiners();
    applyLang();

    document.getElementById('infoWindow') && (document.getElementById('infoWindow').style.display = 'none');
    document.getElementById('infoWindow') && (document.getElementById('infoWindow').setAttribute('aria-hidden','true'));
    document.getElementById('profileWindow') && (document.getElementById('profileWindow').style.display = 'none');
    document.getElementById('profileWindow') && (document.getElementById('profileWindow').setAttribute('aria-hidden','true'));
    if (buyConfirm) { buyConfirm.style.display = 'none'; buyConfirm.setAttribute('aria-hidden','true'); }

    /* ===========================
    Rewards modal logic (uses XTR label)
    ============================ */
    (function(){
      // ... (the entire rewards modal code remains unchanged)
    })();

    /* ===========================
    Casino modal & logic (XTR labels)
    ============================ */
    (function(){
      // ... (the entire casino code remains unchanged)
    })();
  </script>
</body>
</html>
